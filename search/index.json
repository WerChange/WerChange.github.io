[{"content":"你好。\n","date":"2024-09-24T09:58:00+08:00","permalink":"https://werchange.github.io/p/%E6%B5%8B%E8%AF%95/","title":"测试"},{"content":"平衡树\r是一种二叉查找树，其平衡性使得树的深度在$\\log n$以内，增加、删除等操作可以做到 $O(\\log n)$.\n平衡树的实现有多种，本文主要介绍 AVL，Treap，FHQ Treap 与 Splay .\nAVL\r介绍\rAVL 是这些算法中时间复杂度最优秀的，也是码量最大的.\n其原因在于：AVL 是维护绝对平衡，即左子树高度与右子树高度之差 $\\leq 1$\n所以每一次维护造就了优秀的时间复杂度 与超大的码量 .\n平衡维护\r可以说，平衡维护是铸造二叉平衡树最关键的一步，也是最难理解的一步.\n如何维护？\n1.先判断左子树与右子树高度之差.\r2.再判断较高的那一棵子树是它的左子树高还是右子树高.\r3.最后再进行旋转操作使其平衡.\r相信第1步很容易理解，这里不作过多解释.\n为什么会有第2步的判断？\n因为可能出现不同的情况，我们也需要做出不同的旋转.\n如下图，左子树根节点（节点3）的左儿子（节点2）使左子树高度增加为2，而右子树高度为0，所以平衡树不平衡. 再如下图，左子树根节点（节点15）的右儿子（节点18）使左子树高度增加为2，而右子树高度为0，所以平衡树不平衡. 同理，也有右子树高度高于左子树的情况. 明显可见，当多出来的那个节点与它的父亲、父亲的父亲（祖父）成一条线时，只需要通过一次旋转. 当不成一条线时，需要通过两次旋转.\n单旋转分为两种，左旋（zag）与右旋（zig）.\n如下图，为左旋. 如下图，为右旋. 双旋转则多为先进行一次方向旋转，使其呈链状后，再进行一次反方向旋转.\n如下图，为需要维护的不平衡状态. 又如下图，为进行旋转（左旋A，B）使三点共链的状态. 再如下图，为进行反方向旋转（右旋C，B）使其平衡的状态. 最后保持平衡.\n因为其不同方向两次旋转的特性，所以双旋转分为左右旋（zagzig）和右左旋（zigzag）.\n代码实现平衡维护\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void mountain(ll \u0026amp;r) // 注意引用\u0026amp; { ll lf=ls(r),rg=rs(r); // ls(r)为表示r的左儿子的函数，rs(r)反之 if(tr[lf].hi==tr[rg].hi+2) { if(tr[ls(lf)].hi==tr[rg].hi+1) rote(r,1); // 单旋转，1表示zig，0反之 else if(tr[rs(lf)].hi==tr[rg].hi+1) rote2(r,0); // 双旋转，0表示zagzig，1反之 } else if(tr[rg].hi==tr[lf].hi+2) { if(tr[rs(rg)].hi==tr[lf].hi+1) rote(r,0); else if(tr[ls(rg)].hi==tr[lf].hi+1) rote2(r,1); } pushup(r); } 代码实现旋转操作\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void rote(ll \u0026amp;r,ll op) { ll t=tr[r].ch[!op]; tr[r].ch[!op]=tr[t].ch[op]; tr[t].ch[op]=r; pushup(r),pushup(t); r=t; } void rote2(ll \u0026amp;r,ll op) { rote(tr[r].ch[op],op); rote(r,!op); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+5,INF=0x3f3f3f3f; struct AVL { ll ch[2],sz,val,hi,cnt; }tr[MAXN]; ll rt,pcnt; void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void rote(ll \u0026amp;r,ll op) { ll t=tr[r].ch[!op]; tr[r].ch[!op]=tr[t].ch[op]; tr[t].ch[op]=r; pushup(r),pushup(t); r=t; } void rote2(ll \u0026amp;r,ll op) { rote(tr[r].ch[op],op); rote(r,!op); } void mountain(ll \u0026amp;r) { ll lf=ls(r),rg=rs(r); if(tr[lf].hi==tr[rg].hi+2) { if(tr[ls(lf)].hi==tr[rg].hi+1) rote(r,1); else if(tr[rs(lf)].hi==tr[rg].hi+1) rote2(r,0); } else if(tr[rg].hi==tr[lf].hi+2) { if(tr[rs(rg)].hi==tr[lf].hi+1) rote(r,0); else if(tr[ls(rg)].hi==tr[lf].hi+1) rote2(r,1); } pushup(r); } void ins(ll \u0026amp;r,ll x) { if(!r) { tr[++pcnt].val=x,r=pcnt; pushup(r); return; } if(x\u0026lt;tr[r].val) ins(ls(r),x); else ins(rs(r),x); mountain(r); } ll del(ll \u0026amp;r,ll x) { ll tmp; if(tr[r].val==x||x\u0026lt;tr[r].val\u0026amp;\u0026amp;!ls(r)||x\u0026gt;tr[r].val\u0026amp;\u0026amp;!rs(r)) { tmp=tr[r].val; if(!ls(r)||!rs(r)) { r=ls(r)+rs(r); return tmp; } tr[r].val=del(ls(r),x); } else { if(x\u0026lt;tr[r].val) tmp=del(ls(r),x); else tmp=del(rs(r),x); } mountain(r); return tmp; } ll grank(ll r,ll x) { if(!r) return 1; if(x\u0026lt;=tr[r].val) return grank(ls(r),x); return tr[ls(r)].sz+1+grank(rs(r),x); } ll xth(ll r,ll x) { if(tr[ls(r)].sz\u0026gt;=x) return xth(ls(r),x); if(tr[ls(r)].sz+1\u0026gt;=x) return tr[r].val; return xth(rs(r),x-tr[ls(r)].sz-1); } ll pre(ll r,ll x) { if(!r) return -INF; if(tr[r].val\u0026gt;=x) return pre(ls(r),x); return max(tr[r].val,pre(rs(r),x)); } ll nxt(ll r,ll x) { if(!r) return INF; if(tr[r].val\u0026lt;=x) return nxt(rs(r),x); return min(tr[r].val,nxt(ls(r),x)); } int main() { ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(rt,x); if(op==2) del(rt,x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(rt,x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(rt,x)); if(op==5) printf(\u0026#34;%lld\\n\u0026#34;,pre(rt,x)); if(op==6) printf(\u0026#34;%lld\\n\u0026#34;,nxt(rt,x)); } } Treap\r介绍\r虽然 AVL 敲可爱哒~ 但是在考场上真的来得及打吗？\n其实只要你练得够多，最快可在10min内打完，一般人也可以练进12min.\n明显地，维护平衡操作太长了，可不可以省去？\n或许我们用一些随机值赋值给不同节点，使其成为节点的优先级，在构造二叉查找树时使其满足点权有序性与优先级（随机值）有序性.\n如果这样，随机生成的数字一般可以使二叉查找树接近平衡.可理解为相对平衡但不是绝对平衡.\n当然，除非你考前被奆佬%而rp\u0026ndash;， 一般随机值不会刚好使其变成一条链. 在大数据下更具有代表性，即维护平衡树平衡的成功概率与数据大小成正比.\n所以，就有了时间复杂度不如 AVL 优秀，但是足够的—— Treap ！！\n$Treap$=$Tree+Heap$.\n从名字上可见它满足点权有序性（二叉查找 tree ），和优先级（随机值）有序性（大根或小根 heap ）.\n平衡维护\r其实 Treap 的维护与 AVL 很像，这里就不放图了.\n它们之间的区别或许只是维护时的条件不同.\nAVL 是当左右子树高度相差超过1时进行维护 Treap 是当左右子树优先级小于（或大于，这里不作定性要求，但是同一代码中必须都是小于或大于）根节点优先级时进行维护 还有一点，因为 Treap 讲究好写，所以只需要在插入数据的时候维护一下就可以了，删除后不用再次维护.\n代码实现插入数据与维护\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void pushup(ll r) { if (!r) return; tr[r].sz = tr[ls(r)].sz + tr[rs(r)].sz + 1; } void ins(ll \u0026amp;r, ll x) { if (!r) { tr[++pcnt].val = x; tr[pcnt].pri = rand(); r = pcnt; pushup(r); return; } if (x \u0026lt; tr[r].val) { ins(ls(r), x); if (tr[ls(r)].pri \u0026gt; tr[r].pri) rote(r, 1); // 旋转操作见AVL } else { ins(rs(r), x); if (tr[rs(r)].pri \u0026gt; tr[r].pri) rote(r, 0); } pushup(r); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN = 5e5 + 5, INF = 0x3f3f3f3f; struct Treap { ll ch[2], sz, val, pri; } tr[MAXN]; ll rt, pcnt; ll fa[MAXN]; void pushup(ll r) { if (!r) return; tr[r].sz = tr[ls(r)].sz + tr[rs(r)].sz + 1; } void rote(ll \u0026amp;r, ll op) { ll t = tr[r].ch[!op]; tr[r].ch[!op] = tr[t].ch[op]; tr[t].ch[op] = r; pushup(r), pushup(t); r = t; } void ins(ll \u0026amp;r, ll x) { if (!r) { tr[++pcnt].val = x; tr[pcnt].pri = rand(); r = pcnt; pushup(r); return; } if (x \u0026lt; tr[r].val) { ins(ls(r), x); if (tr[ls(r)].pri \u0026gt; tr[r].pri) rote(r, 1); } else { ins(rs(r), x); if (tr[rs(r)].pri \u0026gt; tr[r].pri) rote(r, 0); } pushup(r); } ll del(ll \u0026amp;r, ll x) { ll tmp; // 解释一下，因为平衡树是一种二叉查找树， // 所以可以把叶子结点与“要删除节点”换一下位置， // 这样的话二叉查找树的性质不会被改变， // 也成功地删除了节点（其他版本的平衡树删除维护同理） if (x == tr[r].val || x \u0026lt; tr[r].val \u0026amp;\u0026amp; !ls(r) || x \u0026gt; tr[r].val \u0026amp;\u0026amp; !rs(r)) { tmp = tr[r].val; if (!ls(r) || !rs(r)) { r = ls(r) + rs(r); return tmp; } tr[r].val = del(ls(r), x); } else { if (x \u0026lt; tr[r].val) tmp = del(ls(r), x); else tmp = del(rs(r), x); } pushup(r); return tmp; } ll grank(ll r, ll x) { if (!r) return 1; if (x \u0026lt;= tr[r].val) return grank(ls(r), x); return tr[ls(r)].sz + 1 + grank(rs(r), x); } ll xth(ll r, ll x) { if (tr[ls(r)].sz \u0026gt;= x) return xth(ls(r), x); if (tr[ls(r)].sz + 1 \u0026gt;= x) return tr[r].val; return xth(rs(r), x - 1 - tr[ls(r)].sz); } ll pre(ll r, ll x) { if (!r) return -INF; if (tr[r].val \u0026gt;= x) return pre(ls(r), x); return max(tr[r].val, pre(rs(r), x)); } ll nxt(ll r, ll x) { if (!r) return INF; if (tr[r].val \u0026lt;= x) return nxt(rs(r), x); return min(tr[r].val, nxt(ls(r), x)); } int main() { srand(time(0)); ll n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while (n--) { ll op, x; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;op, \u0026amp;x); if (op == 1) ins(rt, x); if (op == 2) del(rt, x); if (op == 3) printf(\u0026#34;%lld\\n\u0026#34;, grank(rt, x)); if (op == 4) printf(\u0026#34;%lld\\n\u0026#34;, xth(rt, x)); if (op == 5) printf(\u0026#34;%lld\\n\u0026#34;, pre(rt, x)); if (op == 6) printf(\u0026#34;%lld\\n\u0026#34;, nxt(rt, x)); } return 0; } FHQ Treap\r介绍\r可以说，旋转操作是占主流算法的大多数.\n但是一旦牵扯到可连续性等方面乃至理解方面，旋转操作是不太可取的.\n于是范浩强奆佬就发明了不用旋转的 Treap 算法—— FHQ Treap ！！\n也称作无旋 Treap.\n不旋转，怎么维护平衡？\n分裂！！\n合并！！\n分裂操作与合并操作\r分裂split\r分裂操作split是最难理解的也是最关键的一步.\n我们在插入数据和删除数据需要找到一个合适的点.\n而找这个点的路径，可以把树分裂成两部分，把小于等于插入值的分裂到左树，大于的就分裂到右树.\n就这样，我们可以得到两棵树（也有可能是空树）.\n合并merge\r合并操作的对象是两棵树，这两棵树一定满足，左边的树权最大值小于右边的树的权值最小值.\n我们根据其优先级来合并.\n为了描述方面，我们设左边的树为 $L$，右边的树为 $R$.\n首先比较两棵树的树根，谁优先级小，谁就作为新的树根.\n假设 $L$ 的优先级较小，那么 $L$ 的根做新的树根，则问题转换为 $L$ 的右子树与 $R$ 的合并问题了；否则就是 $R$ 的根作为新树的根，问题转换为 $L$ 和 $R$ 的左子树的合并问题了.\n明显地，可以写成递归.\n这样递归下去，直到某棵树为空，则递归结束。\n代码实现split与merge\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void split(ll r,ll \u0026amp;xrt,ll \u0026amp;yrt,ll v) { // r为需要分裂的树的根 // xrt为分裂后将得到左树的树根 // yrt反之 if(!r) xrt=yrt=0; else if(v\u0026lt;tr[r].val) { yrt=r; split(ls(r),xrt,ls(r),v); } else { xrt=r; split(rs(r),rs(r),yrt,v); // 等于v的节点分到左树里 } pushup(r); } void merge(ll \u0026amp;r,ll xrt,ll yrt) { // r为合并后的新根 // xrt为参与合并的左子树的根 // yrt反之 if(!xrt||!yrt) r=xrt+yrt; else if(tr[xrt].pri\u0026lt;tr[yrt].pri) { r=xrt; merge(rs(r),rs(r),yrt); } else { r=yrt; merge(ls(r),xrt,ls(r)); } pushup(r); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rep(c,i,a,b) for(c i=a;i\u0026lt;=b;++i) #define per(c,i,a,b) for(c i=a;i\u0026gt;=b;--i) #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+3,INF=0x3f3f3f3f; struct FHQ_Treap { ll ch[2]; ll sz; ll val; ll pri; }tr[MAXN]; ll pcnt,rt,rt1,rt2; void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void split(ll r,ll \u0026amp;xrt,ll \u0026amp;yrt,ll v) { if(!r) xrt=yrt=0; else if(v\u0026lt;tr[r].val) { yrt=r; split(ls(r),xrt,ls(r),v); } else { xrt=r; split(rs(r),rs(r),yrt,v); } pushup(r); } void merge(ll \u0026amp;r,ll xrt,ll yrt) { if(!xrt||!yrt) r=xrt+yrt; else if(tr[xrt].pri\u0026lt;tr[yrt].pri) { r=xrt; merge(rs(r),rs(r),yrt); } else { r=yrt; merge(ls(r),xrt,ls(r)); } pushup(r); } void ins(ll \u0026amp;r,ll x) { split(r,rt1,rt2,x); tr[++pcnt].val=x,tr[pcnt].pri=rand(),tr[pcnt].sz=1,r=pcnt; merge(rt1,rt1,pcnt); merge(r,rt1,rt2); } void del(ll \u0026amp;r,ll x) { ll rt3; split(r,rt1,rt2,x); split(rt1,rt1,rt3,x-1); merge(rt1,rt1,rt3); merge(r,rt1,rt2); } ll getrank(ll r,ll x) // 数x的排名 { if(r==0) return 1; if(tr[r].val\u0026lt;x) return tr[ls(r)].sz+1+getrank(rs(r),x); return getrank(ls(r),x); } ll xth(ll r,ll x) // 第x个数 { if(tr[ls(r)].sz\u0026gt;=x) return xth(ls(r),x); if(tr[ls(r)].sz+1\u0026gt;=x) return tr[r].val; return xth(rs(r),x-tr[ls(r)].sz-1); } ll getpre(ll r,ll x) // x的前驱 { if(r==0) return -INF; if(x\u0026lt;=tr[r].val) return getpre(ls(r),x); return max(tr[r].val,getpre(rs(r),x)); } ll getnxt(ll r,ll x) // x的后继 { if(r==0) return INF; if(x\u0026gt;=tr[r].val) return getnxt(rs(r),x); return min(tr[r].val,getnxt(ls(r),x)); } int main() { srand(time(0)); ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(rt,x); if(op==2) del(rt,x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(rt,x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(rt,x)); if(op==5) printf(\u0026#34;%lld\\n\u0026#34;,pre(rt,x)); if(op==6) printf(\u0026#34;%lld\\n\u0026#34;,nxt(rt,x)); } return 0; } Splay\r介绍\rSplay 也称为伸展树，它也满足二叉查找树的性质.\n即一个节点的左子树的所有点权都会小于当前节点，右子树反之.\n它和其他平衡树算法最大不同的是，它不需要主动维护平衡，我们只需要在每个操作结束后进行一次splay(x,goal)的操作，它就可以自己维护了.\n当然splay(x,goal)里面还是有旋转操作的.\nsplay(x,goal)伸展操作\rsplay(x,goal)操作也就是伸展操作.\n通过一系列旋转使得 x 转到 goal 节点，旋转也需要分情况而论.\n以下 goal 节点为 root 根节点举例.\n情况一：节点 x 的父节点 y 是根节点. 这时如果 x 是 y 的左儿子，则进行一次 zig 操作；反之同理. 如图 1 所示.\r情况二：节点x的父节点y还有一个父节点z. 且此时三点成链，则进行一次zigzig操作或zagzag操作（是的，此处旋转不需要维护平衡，只是为了将x旋转到目标节点），如图2所示.\r情况三：节点x的父节点y还有父节点z. 且此时三点呈“之”字形，则进行一次zagzig操作或zigzag操作，如图3所示.\r如图5，是一次splay(2,rt)的操作.\n明显地，经过 splay() 操作后，平衡树明显“平衡”了许多.\n所以我们在一些插入、查询等操作后就做一遍 splay().\n这样做的话，时间复杂度可以下降. 但是同样地，常数也就增加了. 所以 Splay 算法是本文 4 个算法中最慢的.\n代码实现 splay(x,goal)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+tr[r].cnt; } void rote(ll x) { ll y=fa[x],z=fa[y],flg=(x==rs(fa[x])); tr[y].ch[flg]=tr[x].ch[!flg]; if(tr[x].ch[!flg]) fa[tr[x].ch[!flg]]=y; tr[x].ch[!flg]=y; fa[y]=x; fa[x]=z; if(z) tr[z].ch[y==rs(z)]=x; pushup(y),pushup(x); } void splay(ll x,ll goal) // 这里goal==0时，表示将x转到根节点 { // 这里3行包含了旋转的3种情况，请自行理解，这里不作过多解释 for(ll y;(y=fa[x])!=goal;rote(x)) if(fa[y]!=goal) rote( ( ( rs(fa[y])==y) == (rs(y)==x) ) ? y : x); if(goal==0) // 如果目标是根节点，那根节点需要更新为x rt=x; } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+5,INF=0x3f3f3f3f; struct Splay { ll ch[2],sz,val,cnt; }tr[MAXN]; ll rt,pcnt; ll fa[MAXN]; void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+tr[r].cnt; } void rote(ll x) { ll y=fa[x],z=fa[y],flg=(x==rs(fa[x])); tr[y].ch[flg]=tr[x].ch[!flg]; if(tr[x].ch[!flg]) fa[tr[x].ch[!flg]]=y; tr[x].ch[!flg]=y; fa[y]=x; fa[x]=z; if(z) tr[z].ch[y==rs(z)]=x; pushup(y),pushup(x); } void splay(ll x) { for(ll y;(y=fa[x]);rote(x)) if(fa[y]) rote(((rs(fa[y])==y)==(rs(y)==x))?y:x); rt=x; } void ins(ll x) { if(!rt) { tr[++pcnt].val=x; tr[pcnt].cnt++; rt=pcnt; pushup(rt); return; } ll cur=rt,f=0; while(1) { if(tr[cur].val==x) { tr[cur].cnt++; pushup(cur); pushup(f); splay(cur); return; } f=cur; cur=tr[cur].ch[tr[cur].val\u0026lt;x]; if(!cur) { tr[++pcnt].val=x; tr[pcnt].cnt++; fa[pcnt]=f; tr[f].ch[tr[f].val\u0026lt;x]=pcnt; pushup(pcnt); pushup(f); splay(pcnt); return; } } } ll grank(ll x) { ll res=0,cur=rt; while(1) { if(tr[cur].val\u0026gt;x) cur=ls(cur); else { res+=tr[ls(cur)].sz; if(tr[cur].val==x) { splay(cur); return res+1; } res+=tr[cur].cnt; cur=rs(cur); } } } ll xth(ll x) { ll cur=rt; while(1) { if(ls(cur)\u0026amp;\u0026amp;tr[ls(cur)].sz\u0026gt;=x) cur=ls(cur); else { x-=tr[ls(cur)].sz+tr[cur].cnt; if(x\u0026lt;=0) { splay(cur); return tr[cur].val; } cur=rs(cur); } } } ll pre() { ll cur=ls(rt); if(!cur) return 0; while(rs(cur)) cur=rs(cur); splay(cur); return cur; } ll nxt() { ll cur=rs(rt); if(!cur) return 0; while(ls(cur)) cur=ls(cur); splay(cur); return cur; } void del(ll x) { grank(x); if(tr[rt].cnt\u0026gt;1) { tr[rt].cnt--; splay(rt); return; } if(!rs(rt)\u0026amp;\u0026amp;!ls(rt)) { rt=0; return; } if(!ls(rt)||!rs(rt)) { rt=ls(rt)+rs(rt); fa[rt]=0; return; } ll cur=rt; ll y=pre(); fa[rs(cur)]=y; rs(y)=rs(cur); pushup(rt); } int main() { ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(x); if(op==2) del(x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(x)); if(op==5) ins(x),printf(\u0026#34;%lld\\n\u0026#34;,tr[pre()].val),del(x); if(op==6) ins(x),printf(\u0026#34;%lld\\n\u0026#34;,tr[nxt()].val),del(x); } return 0; } 最后\r本文写得还是很仓促的，有些漏洞大家原谅一下.(^^)\n本文还有很多不完善的地方，例如 AVL 代码没有指针版、图片模糊等.\n欢迎大家在评论区留下建议或疑问、收藏、转发学习.\n转载请注明出处.\n仅供参考、学习用，不商用.\nThe End\n","date":"2023-01-11T09:21:00+08:00","image":"https://werchange.github.io/img/%E5%B9%B3%E8%A1%A1%E6%A0%91/p12.png","permalink":"https://werchange.github.io/p/%E5%B9%B3%E8%A1%A1%E6%A0%91%E8%AF%A6%E8%A7%A3/","title":"平衡树详解"},{"content":"凸透镜成像原理\r前言\r凸透镜成像原理是个有意思的知识。初二教科书会以实验的方式告诉我们原理。\n快要参加中考了，复习的时候老师说了一条公式：\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ 但它为什么是对的，所以来证明一下。\n几何法\r要点：三角形相似。\n证明\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ $证：$\n$\\because\\triangle ABO\\triangle A\u0026rsquo;B\u0026rsquo;O$ $\\qquad$ (三角形ABO相似于三角形A\u0026rsquo;B\u0026rsquo;O)\n$\\therefore AB:A\u0026rsquo;B\u0026rsquo;=u:v$\n$\\because\\triangle COF∽\\triangle A\u0026rsquo;B\u0026rsquo;F$\n$\\therefore CO:A\u0026rsquo;B\u0026rsquo;=f:(v-f)$\n$\\because 四边形ABOC为矩形$\n$\\therefore AB=CO$\n$\\therefore AB:A\u0026rsquo;B\u0026rsquo;=f:(v-f)$ $\\therefore u:v=f:(v-f)$\n$\\therefore u(v-f)=vf$\n$\\therefore uv-uf=vf$\n$\\because uvf\\neq 0$\n$\\therefore \\frac{uv}{uvf}-\\frac{uf}{uvf}=\\frac{vf}{uvf}$\n$\\therefore \\frac{1}{f}-\\frac{1}{v}=\\frac{1}{u}$\n$即$\n$\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}$\n$证毕$.\n函数法\r要点：一次函数，正比例函数。\n证明\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ 步骤\n（一）为便于用函数法解决此问题，将凸透镜的主光轴与平面直角坐标系的横坐标轴（$x$ 轴）关联（即重合），将凸透镜的理想折射面与纵坐标轴（$y$ 轴）关联，将凸透镜的光心与坐标原点关联.则：点 $A$ 的坐标为 $(-u,c)$，点 $F$ 的坐标为 $(f,0)$，点 $A\u0026rsquo;$ 的坐标为 $(v,-d)$，点 $C$ 的坐标为 $(0,c)$.\n（二）将 $AA\u0026rsquo;$，$A\u0026rsquo;C$ 双向延长为直线 $l_1$,$l_2$，视作两条函数图象.由图象可知：直线 $l_1$ 为正比例函数图象，直线 $l_2$ 为一次函数图象.\n（三）设直线 $l_1$ 的解析式为 $y=k_1x$，直线 $l_2$ 的解析式为 $y=k_2x+b$.\n依题意，将 $A(-u,c)$，$C(0,c)$，$F(f,0)$ 代入相应解析式，得\n$$\r\\begin{cases}\rc=-uk_1\\\\\rc=b\\\\\r0=k_2f+b\r\\end{cases}\r$$ 得\n$$\r\\begin{cases}\rk_1=-\\frac{c}{u}x\\\\\rk_2=-\\frac{c}{f}\r\\end{cases}\r$$ $\\therefore 两函数解析式为$\n$$\ry=-\\frac{c}{u}x\\\\\ry=-\\frac{c}{f}x+c\r$$ $\\therefore 两函数交点 A\u0026rsquo;(x,y) 满足方程组$\n$$\r\\begin{cases}\ry=-\\frac{c}{u}x\\\\\ry=-\\frac{c}{f}x+c\r\\end{cases}\r$$ $\\because A\u0026rsquo;(v,-d)$\n$$\\therefore\r\\begin{cases}\r-d=-\\frac{c}{u}v\\\\-d=-\\frac{c}{f}v+c\r\\end{cases}$$ $\\therefore -\\frac{c}{u}v=-\\frac{c}{f}v+c=-d$\n$\\therefore \\frac{c}{u}v=\\frac{c}{f}v+c=d$\n$\\therefore \\frac{cv}{u}=\\frac{cv}{f}+c$\n$\\therefore cvf=cuv-cuf$（两边同乘 $uf$）\n$\\therefore vf=uv-uf$\n$\\because uvf\\neq0$\n$\\therefore \\frac{vf}{uvf}=\\frac{uv}{uvf}-\\frac{uf}{uvf}$\n$\\therefore \\frac{1}{u}=\\frac{1}{f}-\\frac{1}{v}$\n$即$\n$\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}$\n$证毕.$\n结尾\r这篇文章之前写过了，2024.6.6 进行了修改，使其更加可读。\n","date":"2022-11-29T19:23:00+08:00","image":"https://werchange.github.io/img/%E5%87%B8%E9%80%8F%E9%95%9C/p1.png","permalink":"https://werchange.github.io/p/%E5%87%B8%E9%80%8F%E9%95%9C%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86/","title":"凸透镜成像原理"},{"content":"update:2023.07.19 更新了堆优化版本的 Dijkstra\nupdate:2023.09.21 更新了时间复杂度讨论并修改了堆优化 Dij\nDijkstra\r什么是Dijkstra\rDijkstra采用了贪心的策略。\n在一张连通图中，我们将点分类为已知点和未知点。\n什么是已知点？就是已经遍历过的，例如原点（出发点）就是一个已知点。\n什么是未知点？顾名思义，就是未遍历到的点（除了已知点，剩下的就是未知点）\n理解贪心策略\r这里举一个简单的栗子：\n夏福要去 supermarket，他面前可以选择 3 个商店：\n1.壹加壹超市，据夏福 1000m 2.美宜佳商店，据夏福 500m 3.711超市，据夏福 200m 他该去哪个超市呢？\n这里很容易看出来，肯定是选择第 3 种方案。\n没错，这就是从夏福（原点）到超市（终点）的最短路径。也就是贪心策略。\n思考实现代码\r因为贪心只能保证局部最优，不能保证全局最优，所以我们还是需要去遍历，但是我们可以缩小遍历的范围。\n假想现在从已知点可以到达三个中转站，最后都可以到终点。\n那么从起点到终点的路径就是：起点到中转站的路径 + 中转站到终点的路径\n我们想让起点到中转站的距离尽可能的小，那肯定是选择据起点最近的中转站作为新的起点（新的已知点）\n我们就可以把那个点当作起点，继续找最短路径就好了。\n原来那个点怎么办？\n丢进垃圾桶里~\n代码实现\r题目： 输出从 $s$ 到 $t$ 的最短路，并换行输出最短路径 Input\n1 2 3 4 5 6 7 8 9 5 7 1 2 10 1 4 30 1 5 100 2 3 50 3 5 10 4 3 20 4 5 60 1 5 Output\n1 2 60 1 4 3 5 Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; int edge[505][505]; int ss, tt; bool vis[505]; pair\u0026lt;int, int\u0026gt; dis[505]; // 相当于一个变量里有两个成员：一个是距离，另一个是数组下标所连接的点 vector\u0026lt;int\u0026gt; q[505]; vector\u0026lt;int\u0026gt; ans; bool cmp(int a, int b) { return a \u0026lt; b; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // 输入点的个数n，边的数量m for (int i = 1; i \u0026lt;= m; i++) { int l, r, v; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;v); // 输入边的信息：边连接的两个点l、r，和边的权值v edge[l][r] = v; // 表示从l到r这个点的权值是v /* 因为这个代码是有向图的最短路问题，如果是无向图的话应该再加上下面这行代码： edge[r][l] = v; 这个表示r到l的路径边权是v */ } scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;ss, \u0026amp;tt); // 输入ss（原点）和tt（终点），这个代码是输出从ss到tt的最短路径 for (int i = 1; i \u0026lt;= n; i++) dis[i].first = 1e9; // 初始化从原点到第i个点的路径全部为正无穷（这里只要数据够大就行了） fill(vis, vis + n + 1, 0); // 初始化所有的点都没被访问过 dis[ss].first = 0; // 从原点到原点的距离肯定是0 dis[ss].second = ss; // 默认原点和原点相连 for (int i = 1; i \u0026lt;= n; i++) { int tmp = -1; // 存储下标的临时变量 for (int j = 1; j \u0026lt;= n; j++) { if (!vis[j] \u0026amp;\u0026amp; (tmp == -1 || dis[j] \u0026lt; dis[tmp])) { // 只要 (j未被访问过) 并且只要达到 [(tmp未赋值) 或 (找到离i点有更近的点)] 的条件之一 tmp = j; // tmp就赋值为j } } vis[tmp] = 1; // 完事之后，备注tmp已经被访问过了，丢进**垃～圾～桶～**里 for (int j = 1; j \u0026lt;= n; j++) { if (dis[tmp].first + edge[tmp][j] \u0026lt; dis[j].first \u0026amp;\u0026amp; tmp != j \u0026amp;\u0026amp; edge[tmp][j]) { /* 如果 (到tmp的距离 + tmp到j的距离 \u0026lt; 原来到j的距离) 并且 (tmp和j不是同一个点) 并且 (tmp到j的距离不是0) 的话 */ dis[j].first = dis[tmp].first + edge[tmp][j]; dis[j].second = tmp; // 到j的距离重新赋值，与j相邻的点就变为tmp } } } printf(\u0026#34;%d\\n\u0026#34;, dis[tt].first); // 输出终点的距离 int temp = tt; while (dis[temp].second != ss) // 只要与temp这个临时变量相邻的不是起点，就进行 { ans.push_back(temp); // 把temp存储进ans数组里 temp = dis[temp].second; // temp就重新赋值 } ans.push_back(temp); // 最后一个点会跳出循环，所以要存储 ans.push_back(ss); // 把原点也放进去 for (int i = ans.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d \u0026#34;, ans[i]); // 倒过来输出就行了 } } 注意：\rDijkstra 采用的是贪心的策略，所以遇上有负边的图时，它就会陷入自环中。\nSPFA\r什么是 SPFA\r相对 Dijkstra 来讲，在随机生成数据中，会比Dijkstra会更快一点。\n它是基于邻接表的基础写的。\n理解邻接表\r在一张连通图中，一个点并不总是只连着一个点。\n举个粒子：\n小 A 家处于十字路口，可以从小 A 家到小 B 家、小 C 家、小 D 家等多个 good friends 的家。\n而对于小 A 家的邻接表就是： $B\\to C\\to D$\n代码实现\r题目：给一堆数据，输出 $1$ 到 $n$ 的最短路 Input\n1 2 3 4 5 6 7 8 4 7 1 2 68 1 3 19 1 4 66 2 3 23 3 4 65 3 2 57 4 1 68 Output\n1 66 Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; struct edge { int s, e, val; }; int maxx = INT_MIN; int step; vector\u0026lt;edge\u0026gt; b[5005]; queue\u0026lt;int\u0026gt; q; int dis[5005]; bool vis[5005]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { int x, y, v; edge ee; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v); ee.s = x, ee.e = y, ee.val = v; b[x].push_back(ee); // 存储x的邻接表 } fill(dis, dis + n + 1, 1e9); // 初始化路径全部为正无穷（数据足够大就行） q.push(1); dis[1] = 0; vis[1] = 1; while (!q.empty()) { // STL宽搜 step++; if (step \u0026gt; m) { // 出现负环，直接退出 printf(\u0026#34;No Solution\u0026#34;); return 0; } int u = q.front(); q.pop(); for (int i = 0; i \u0026lt; b[u].size(); i++) { // 对于当前这个u点的邻接点 int vv = b[u][i].val; int en = b[u][i].e; if (dis[u] + vv \u0026lt; dis[en]) { // 如果 (到u点距离) + (从u点到它的邻接点的距离) \u0026lt; (原来的到en的距离) dis[en] = dis[u] + vv; if (!vis[en]) { // 在压入队列之前进行标记，否则会陷入死循环 vis[en] = 1; q.push(en); } } } vis[u] = 0; // 标记这个点《 免 费 》了（free这个点） } printf(\u0026#34;%d\u0026#34;, dis[n]); } Floyd\r什么是 Floyd\r就是运用枚举中间点进行松弛（专业术语，指令这个点距离最小）每个点的距离。\n理解枚举中间点\r还是举个梨子：\n小 A 和小 B 有一定的亲密度，为了使他们的亲密度更近，需要一个中介来帮忙。通过中介的帮忙，他们是否能提升之间的亲密度呢？所以我们就枚举一下。\n代码实现\rCode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (i != j \u0026amp;\u0026amp; i != k \u0026amp;\u0026amp; j != k) { if (dis[i][k] + dis[k][j] \u0026lt; dis[i][j]) { dis[i][j] = dis[i][k] + dis[k][j]; // 这样写的话，无论是有向图还是无向图都成立 } } } } } 但是这个时间复杂度是\n$O(n^3)$\n《没 逝 ， 就 慢 了 亿 点 点》\n堆优化Dijkstra\r思想\r因为Dijkstra类似于贪心的策略，每次都选择边权最小的边。如果我们用小根堆来维护呢？\n是的，所以堆优化 Dijkstra 用到了优先队列优化。\n因为曾有“关于 SPFA ——他死了”的一说，所以这个就很吃香。更好的是，这个和 SPFA 代码实现很像，所以直接入手是很容易的。\n代码实现\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN=500+5,MAXM=500+5,INF=0x3f3f3f3f3f3f3f3f; int n,m; int dis[MAXN]; bool vis[MAXN]; int su,en[MAXM\u0026lt;\u0026lt;1],vl[MAXM\u0026lt;\u0026lt;1],hd[MAXN],lt[MAXM\u0026lt;\u0026lt;1]; struct node { int id,dis; bool operator\u0026gt;(const node \u0026amp;T)const { return dis\u0026gt;T.dis; } }; void add(int u,int v,int w) { en[++su]=v,vl[su]=w,lt[su]=hd[u],hd[u]=su; } int Dij() { priority_queue\u0026lt;node,vector\u0026lt;node\u0026gt;,greater\u0026lt;node\u0026gt;\u0026gt; q; memset(vis,0,sizeof(vis)); memset(dis,0x3f,sizeof(dis)); dis[1]=0,vis[1]=1; q.push({1,0}); while(!q.empty()) { int u=q.top().id;q.pop(); for(int i=hd[u];i;i=lt[i]) { int v=en[i],w=vl[i]; if(dis[v]\u0026gt;dis[u]+w) { dis[v]=dis[u]+w; if(!vis[v]) { vis[v]=1; q.push({v,dis[v]}); } } } vis[u]=0; } if(dis[n]==INF) return -1; return dis[n]; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=m;i++) { int u,v,w; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v,w),add(v,u,w); } printf(\u0026#34;%lld\\n\u0026#34;,Dij()); return 0; } 时间复杂度讨论\r堆优化 Dij：$O(m\\log m)$\n朴素 Dij：$O(n^2)$ SPFA：$O(nm)$（最坏情况） Floyd：$O(n^3)$\n一般来说，无负边权就选择 Dij，对于是否采用堆优化，取决于图的稀疏程度。\n关于 SPFA…… ","date":"2022-06-02T20:32:00+08:00","image":"https://werchange.github.io/img/%E6%9C%80%E7%9F%AD%E8%B7%AF/spfa.png","permalink":"https://werchange.github.io/p/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","title":"图论——最短路径问题"}]