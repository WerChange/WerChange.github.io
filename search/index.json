[{"content":"浅谈 AC 自动机\r前言\r这不是第一次看到这个算法。第一次是在 OI-wiki 上瞄到的。当时我还是一个什么也不懂的初一蒟蒻，看到这个名字就十分兴奋：“‘AC 自动机’耶！是不是可以帮我自动 AC ！?”\n后来看到只是一个字符串算法，就离开了。今天上课讲了这个，感觉原理及实现没有后缀数组那么难（还没做几道应用题）。趁一节晚修，来写篇笔记吧。\n食用指南：要先学会 Trie树；KMP的话，理解到思想（$\\text{next}$ 数组）就可以了，不一定要学得透透的。\nAC 自动机到底是什么？\rAC 自动机是 以 Trie 的结构为基础，结合 KMP 的思想 建立的自动机。\n之所以称为 AC 自动机，是因为此算法是由 Alfred V. Aho 和 Margaret J.Corasick 发明的，称为 Aho–Corasick 算法。\n所以他不是 Automation，更不是 Accepted，而是 Automaton（自动机）。\nAC 自动机可以用来干什么？\r他是处理字符串的算法。\n具体的，他可以解决多模式匹配的问题。\nKMP 算法也是解决字符串匹配的，但他处理的问题只有一个模式串（需要寻找的串）和一个文本串（在这个串里寻找）。\n而 AC 自动机，就可以解决多模式串匹配的问题。\n算法思路\r简单来说，建立一个 AC 自动机有两个步骤：\nTrie 结构：将所有的模式串构建成一棵 Trie 树。 KMP 的思想：在 KMP 中，一旦失配，就跳到 $\\text{next}$ 失配指针所指的下一个字符；所以 AC 自动机中，也要对整颗 Trie 树所有节点构造失配指针。 那我们现在就开始吧。\nTrie 树\r回忆一下 AC 自动机的思路：首先把所有的字符串全部丢进 Trie 树里面，然后再在 Trie 树上构建自动机。\n这个 Trie 树构建就很简单了，该怎么建就怎么建。详细内容可以看我的其他博客。\n这里有一些需要理解的，就是一个节点到根节点的路径正是一个（或多个）模式串的前缀。\n下文也把节点 $x$ 到根节点的路径上的字符串称为状态 $x$。\n失配指针\r首先要明确一点：这里的“指针”并不是 C++ 中真正的“指针类型”，只是一个形象化的称号。\nAC 自动机通过失配指针（下文称为 $\\text{fail}$ 指针）来辅助多模式串的匹配。\n与 KMP 的 $\\text{next}$ 失配指针关系\r相同点：两者同样是在失配的时候用于跳转的指针。 不同点：$\\text{next}$ 求的是最长的相同前后缀；而 $\\text{fail}$ 指针指向所有模式串的前缀中与当前节点“匹配”的“最长后缀”。 等等！这个“匹配”和这个“最长后缀”都是些什么东西？\n先解释一下 $\\text{fail}$ 指针吧。\n如果状态 $x$ 的 $\\text{fail}$ 值是状态 $y$，要求是：$y$ 是 $x$ 的最长后缀。\n用人话说，就是：\n先规定从节点 $x$ 到根节点路径上形成的字符串为 $\\text{sub}(x)$；这个字符串中，第一个是根节点，最后一个是 $x$ 节点上的字母。\n如果 $\\text{sub}(y)$ 正好是 $\\text{sub}(x)$ 的后缀，并且不存在任意一个 $\\text{sub}(y\u0026rsquo;)$ 的长度大于 $\\text{sub}(y)$ 的长度。\n那么 $\\text{fail}(x)=y$。\n举个例子：\n如果以 i,he,his,she,hers 这些单词构建 $\\text{fail}$ 指针：\n假设紫圈是 $3$ 号节点，红圈是 $7$ 号节点，那么 $\\text{fail}[3]=7$。\n因为 she 的最长后缀（整棵 Trie 中）是 he。\n如果你看到这里，还是看不懂与KMP的区别，不要紧；你只需知道 AC 自动机的失配指针指向当前状态的最长后缀状态即可。\n有一点提一下，AC 自动机在做匹配时，同一位上可匹配多个模式串。\n构建 $\\text{fail}$ 指针\r构建 $\\text{fail}$，可以参考 KMP 中构建 $\\text{next}$ 的思想。\n假设字典树中当前节点为 $u$，父节点为 $fa$，并且 $\\text{sub}(u)=\\text{sub}(fa)+c$（记为 $\\text{trie}[fa,c]=u$）我们考虑深度比 $u$ 小的节点的 $\\text{fail}$ 都已得到。\n如果 $\\text{trie}[\\text{fail}[fa],c]$ 存在，则 $\\text{fail}[u]=\\text{trie}[\\text{fail}[fa],c]$。相当于分别在 $fa$ 和 $\\text{fail}[fa]$ 下面加了一个字符 $c$，分别对应 $u$ 和 $\\text{fail}[u]$。 如果 $\\text{trie}[\\text{fail}[fa],c]$ 不存在，则继续寻找 $\\text{trie}[\\text{fail}[\\text{fail}[fa]],c]$。重复 1 的判断，一直跳到根节点。 一直跳到了根节点都没有，那就让 $\\text{fail}[u]$ 指向根节点。 通过以上过程就可以完成 $\\text{fail}$ 的构建。\n代码实现构建 $\\text{fail}$ 指针\r尽管网上有许多实现方式，这里我们来看一下 OI-wiki 上的一种实现。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void build() { for (int i = 0; i \u0026lt; 26; i++) if (tr[0][i]) q.push(tr[0][i]); while (q.size()) { int u = q.front(); q.pop(); for (int i = 0; i \u0026lt; 26; i++) { if (tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]); else tr[u][i] = tr[fail[u]][i]; } } } 这里的 tr[u,c] 有两种理解方式：\n字典树上的一条边，即 $\\text{trie}[u,c]$。 状态（节点） $u$ 后加一个字符 $c$ 到达的新节点（状态）。 这里采用第 2 种方式讲解。\n先讲一下这两行为什么这么写：\n1 2 for (int i = 0; i \u0026lt; 26; i++) if (tr[0][i]) q.push(tr[0][i]); 我们为什么是把根节点的儿子入队，而非直接把根节点入队呢？\n试想一下，如果将根节点入队，那么第一次 bfs 的时候根节点儿子的 $\\text{fail}$ 指针就会指向自己。\n常规 bfs 这里就不提及了，主要讲一下 for 循环中的 if 与 else 的“神仙实现”。\nfor 循环为什么这么写？——“神仙操作”，路径压缩\r先解释一下代码最基础的意思：\n如果 tr[u][i] 存在，我们就将 tr[u][i] 的 $\\text{fail}$ 指针赋值为 tr[fail[u]][i]。 否则，令 tr[u][i] 指向 tr[fail[u]][i]。 操作 1 貌似和上文讲的不太一样啊？——\n根据上文，不应该是用 while 循环不停地跳、跳、跳 $\\text{fail}$ 指针，直到存在字符 i 对应的节点后再赋值吗？而且 else 里的操作直接改变了树的结构了呀？！！\n其实这里做了一点“神仙处理”。\n这个处理就是通过 else 改变字典树的结构。但值得注意的是，尽管我们将一个不存在的节点添加了一些指向关系，但是节点所代表的的字符串还是不变的。\n由于 tr[S][c] 表示在 $S$ 后增加一个字符 $c$ 得到新字符串 $S\u0026rsquo;$，这里要考虑 $S\u0026rsquo;$ 是否存在。\n存在，说明有某个模式串的前缀为 $S\u0026rsquo;$。 不存在，让 tr[S][c] 指向 tr[fail[S]][c]。这是因为 fail[S] 对应的字符串是 $S$ 的后缀，那么 tr[fail[S]][c] 对应的字符串也就是 $S\u0026rsquo;$ 的后缀。 但为什么可以这么写？\n在 Trie 树上跳的时候，是从 $S$ 跳到了 $S\u0026rsquo;$；但是在 AC 自动机上，是从 $S$ 跳到了 $S\u0026rsquo;$ 的后缀。——因为 AC 自动机本质上是为了匹配，舍弃掉前面一些前缀也是可以匹配的，所以这里没有问题。\n溯回本源，我们这个 Build() 说到底是在构建 $\\text{fail}$，现在我们来考虑一下 $\\text{fail}$ 是否也满足“舍弃前缀依然可匹配”这一推论。\n显然可以，一旦文本串匹配 $S$，自然能匹配 $S$ 的后缀。所谓的 $\\text{fail}$ 指针其实是 $S$ 的一个后缀集合。\n什么？还是看不懂？其实还有一种简单粗暴的理解方式。\n简单粗暴的理解\r如果在位置 $x$ 失配，我们跳到 $\\text{fail}[x]$。因此有的时候需要跳、跳、跳很多次才能来到下一个匹配的位置。\n所以我们可以用 tr 数组直接记录下一个能匹配的位置，以省时间。\n本质上，与并查集路径压缩一样，这其实就是一种路径压缩。\n“神仙操作”的好处\r通过这种修改过后，匹配转移更加的完善，同时将 $\\text{fail}$ 指针跳转路径做了压缩。\n这里本来想放图的，但是画出来很乱，不美观，所以建议去 OI-wiki 上看 gif（虽然也很乱，但起码比作者画得好）。\n多模式匹配\r代码实现\rcode\n1 2 3 4 5 6 7 8 9 10 int query(char *t) { int u = 0, res = 0, len = strlen(t + 1); for (int i = 1; i \u0026lt;= len; i++) { u = tr[u][t[i] - \u0026#39;a\u0026#39;]; // 转移 for (int j = u; j \u0026amp;\u0026amp; e[j] != -1; j = fail[j]) { res += e[j], e[j] = -1; } } return res; } $u$ 表示当前匹配到的节点，res 表示答案，e[j] 表示节点存储的信息（根据题目变化）。\n循环遍历匹配串，$u$ 则不断跟踪字符，利用 $\\text{fail}$ 指针找出所有匹配的模式串，累加到 res，然后标记已访问。\n优化代码效率\r这里可不是卡常，而是算法上的优化。\n首先，大家可以去做一下 这道题。\n发现会 T。这是因为在 AC 自动机中，每次匹配都会向 $\\text{fail}$ 边跳来找到所有的匹配。这样效率极低，即是路径压缩也没用。\n考虑一下 $\\text{fail}$ 的性质：\n一个 AC 自动机中，如果值保留 $\\text{fail}$ 边，剩余的图一定是一棵树。\n这个很显然，因为 $\\text{fail}$ 不会成环，且深度一定比现在低。\nAC 自动机的匹配就可以转化成在 $\\text{fail}$ 树上的链求和问题了。\n这里介绍拓扑排序。\n拓扑排序优化建图\r原来时间都浪费在“跳 $\\text{fail}$”上了。如果预先记录，最后一并求和，那么效率就会被优化。\n代码实现中，不需要真正的建图，记录入度就可以了。\n查询操作也只需要给找到的节点的 ans 打标记，最后拓扑排序求答案就好了。\n建图实现\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void getfail() // 实际上也可以叫 build { for (int i = 0; i \u0026lt; 26; i++) trie[0].son[i] = 1; q.push(1); trie[1].fail = 0; while (!q.empty()) { int u = q.front(); q.pop(); int Fail = trie[u].fail; for (int i = 0; i \u0026lt; 26; i++) { int v = trie[u].son[i]; if (!v) { trie[u].son[i] = trie[Fail].son[i]; continue; } trie[v].fail = trie[Fail].son[i]; indeg[trie[Fail].son[i]]++; // 修改点在这里，增加了入度记录 q.push(v); } } } 查询实现\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void query(char *s) { int u = 1, len = strlen(s); for (int i = 0; i \u0026lt; len; i++) u = trie[u].son[s[i] - \u0026#39;a\u0026#39;], trie[u].ans++; } void topu() { for (int i = 1; i \u0026lt;= cnt; i++) if (!indeg[i]) q.push(i); while (!q.empty()) { int fr = q.front(); q.pop(); vis[trie[fr].flag] = trie[fr].ans; int u = trie[fr].fail; trie[u].ans += trie[fr].ans; if (!(--indeg[u])) q.push(u); } } 主函数\r1 2 3 4 5 6 7 8 9 int main() { // do_something(); scanf(\u0026#34;%s\u0026#34;, s); query(s); topu(); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; vis[rev[i]] \u0026lt;\u0026lt; std::endl; // do_another_thing(); } 完整代码就不挂了，洛谷题解区有一堆。\n参考文献\r[1] OI-wiki，《AC 自动机》 [2] DengDuck，《AC 自动机 ACAM 学习笔记》 结尾\r一节晚修写完，除了板题，其他的题还没做，作者溜去做题了。\n如有侵权，联系作者解决。\n希望能帮到你，Thank you!\n","date":"2024-01-16T22:24:00+08:00","image":"https://werchange.github.io/img/AC/p1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88-ac-%E8%87%AA%E5%8A%A8%E6%9C%BA/","title":"浅谈 AC 自动机"},{"content":"浅谈 Trie 树\r什么是 Trie 树？\rTrie 树，又称字典树，可用于存储单词。\nTrie 树的根节点不表示任何字母，但是除了根节点的所有字母都表示一个字母。\n任何一个单词，都可以用一条从根节点出发的路径表示。在路径的终点做一个“结束”标记，对应一个单词的结尾。\n举个例子：要存储 work,word,world,hello 这些单词。\n红色节点表示“结束”标记。\n可以看到，叶子节点都是一个单词的结尾；但是并不是所有的单词结尾都是叶子节点。\n再举个例子：假如要多存储一个 worker 单词。\nTrie 树的好处之一，如果两个单词有公共前缀，则有公共路径，可以节省空间。\n存储结构\rTrie 树中的每个节点都可以用一个结构体来存储。\ncode\n1 2 3 4 struct node{ bool flg; // 结束标记 int son[MAXC]; // 儿子们的“指针”，MAXC表示字符集的大小 }Trie[MAXN]; // MAXN表示Trie树的节点数 节点的字母（值）怎么表示？\n一般在程序中，都是去枚举节点 $i$，所以一般不用结构体来表示节点的字母。\n构建 Trie 树\r先分配足够大的空间（Trie 树），也就是定义足够大的 node 数组。\n然后每读入一个单词，就插入在 Trie 树当中。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define MAXC 26 struct node{ bool flg; int son[MAXC]; }Trie[MAXN]; int root=1,tot=1; void ins(int r,char *s){ int len=strlen(s),val; for(int i=0;i\u0026lt;len;i++){ val=s[i]-\u0026#39;a\u0026#39;; if(Trie[r].son[val]==0) Trie[r].son[val]=++tot; r=Trie[r].son[val]; } Trie[r].flg=1; } 查询节点\r1 2 3 4 5 6 7 8 9 bool query(int rt,char *s){ int len=strlen(s),val; for(int i=0;i\u0026lt;len;i++){ val=s[i]-\u0026#39;a\u0026#39;; rt=Trie[rt].son[val]; if(rt==0) return 0; } return Trie[rt].flg; } 此代码可以返回“查询串”（char *s）的结尾的信息。\n这里返回了 Trie[rt].flg，仅作示范。在实践中，可以返回 Trie[rt].cnt 等等定义的变量。\n例 1 ：单词查找树\rP5755 [NOI2000] 单词查找树\n算法分析\r就是裸的 Trie 树，模板题。\ncode（这里直接复制了 Alex_Wei 的代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int cnt,q[1\u0026lt;\u0026lt;15][26];//cnt为节点个数，q为儿子编号 int main(){ while(cin\u0026gt;\u0026gt;s){ int pos=0; for(int i=0;i\u0026lt;s.size();i++){ int ch=s[i]-\u0026#39;A\u0026#39;; if(!q[pos][ch])q[pos][ch]=++cnt;//如果没有这个节点，就新建一个 pos=q[pos][ch]; } } cout\u0026lt;\u0026lt;cnt+1\u0026lt;\u0026lt;endl;//本题中root也算一个节点，别忘了+1 return 0; } ","date":"2024-01-16T09:54:00+08:00","image":"https://werchange.github.io/img/trie/1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88-trie-%E6%A0%91/","title":"浅谈 Trie 树"},{"content":"浅谈基数排序\r前言\r注意，本贴的算法是基数排序而不是计数排序。这两者差别不大，但是存在着一定差异。\n一句话做法\r从低位到高位，每次都把所有要排序的数（含前导 $0$）丢入相应的桶（$0$~$9$），再从小到大（对于桶的编号而言从小到大）取出来，一定次数后，原数组有序。\n数据模拟\r假如要对以下几个数排序。\n1 103 7 65 234 932 45 第一轮，看个位\r此刻数组为：\n1 932 103 234 45 65 7 第二轮，看十位\r此刻数组为：\n1 7 103 932 234 45 65 第三轮，看百位\r此刻数组为：\n1 7 45 65 103 234 932 此时尽管数组已经有序，但过程并未完整。因为对于一些数据是不一定如此凑巧提前就能排好序的。\n第四轮，看千位\r此刻数组为：\n1 7 45 65 103 234 932 数组已经有序。\n证明\r注：以下考虑正整数。“数字”是 $[0,9]$ 之间的，“数”是 $[0,+\\infty)$。\n在小学一年级的时候，我们就已学过如何比较数之间的大小。\n首先看数的位数，位数大的，肯定较大。\n其次从高到低比较每位上的数字大小，一直到不等的时候，哪个数字大，那个数就大。\n因此，基数排序的原理也是一样的。\n首先从最低位开始放，就可以确定当前位的数字的相对大小关系。\n然后考虑再高一位的时候（不妨称为“升位”），那些位数不够的数就会全部放入 $0$ 的桶里。\n由于我们是按从小到大的顺序将不同的桶的元素放入 $0$ 号桶，所以保证了“桶底”的一定是最小的。\n","date":"2024-01-15T22:09:00+08:00","image":"https://werchange.github.io/img/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/p1.png","permalink":"https://werchange.github.io/p/%E6%B5%85%E8%B0%88%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","title":"浅谈基数排序"},{"content":"超级简单的后缀数组（SA）！！\r前言\r这里选择当一手标题党。\n由于刚学完这个字符串算法，本人字符串算法又比较薄弱，好不容易这一次在晚修看各种资料看得七七八八，决定趁脑子清醒的时候记录下来。\n免得自己不久后忘了后又要痛苦地再看各种资料。希望这篇博客能帮到你。\n前置知识：RMQ 问题、基数排序、lcp 问题\n使用指南：在抽象的时候，可以选择先不看证明；先记住结论，顺一遍后再返回来补证明也是可以的。如果有草稿本和笔，是最佳的选择。\n到底什么是“后缀数组”？\r后缀，顾名思义，即为 $[i,..,n]$ 的区间。以 $S$ 的第 $i$ 个字符开始的后缀定义为 $\\text{Suffix}(i)$，下文简写为 $\\text{suf}(i)$。\n如果这玩意儿（后缀）碰上了字符串，那么后缀也就成了特殊的字串。\n后缀数组又是什么呢？\n“后缀数组——处理字符串的有力工具。”——国集选手罗穗骞\n说到底，这是一个处理字符串的基础算法。\n学会 后缀自动机（SAM） 之后是不是就可以不学 后缀数组（SA） 了？不！虽然 SAM 更为强大和全面，但是有些问题 SA 将体现出优势，只单方面地掌握 SAM 是远远不够的。\n例子：求一个串后缀的 lcp 方面的应用，SA 可以直接用 RMQ，但是 SAM 还要求出 LCA。等等。\n那现在让我们开始吧。\n后缀数组与名次数组\r此“后缀数组”非彼“后缀数组”，此二级标题中的“后缀数组”是一个实打实的数组。定义为：$\\text{SA}[i]$，存储的是 $1,\u0026hellip;,n$ 的一个排列。\n他保证 $\\text{suf}(\\text{SA}[i])\u0026lt;\\text{suf}(\\text{SA}[i+1])$，就是将 $S$ 的后缀从小到大排序后把后缀的开头按序放入 $\\text{SA}$ 中。\n名次数组 $\\text{Rank[i]}$ 存储的是 $\\text{suf}(i)$ 在所有后缀中排序后的名次。\n一言了之，$\\text{SA}[i]$ 表示原串中从小到大排名为 $i$ 的是哪个后缀；$\\text{Rank}[i]$ 表示原串中后缀 $i$ 从小到大排名后的名次。\n“简单的说，后缀数组是‘排第几的是谁？’，名次数组是‘你排第几？’。”——罗穗骞\n显然，这俩玩意儿就是双映射关系，说白了就是运算互逆。\n怎么求出这两个数组？——倍增算法\r大家都可以想到的朴素算法或时间复杂度不优秀的算法这里就不再提及了。\n由于过于复杂的 $\\text{DC3}$算法 本人又不会，所以这里只提及 $\\text{O}(n \\log n)$ 的倍增算法。\n主要思路：对每个字符开始长度为 $2^k$ 的子串进行排序，求出 $\\text{Rank}$ 值。\n$k$ 从 $0$ 开始，每次不断 $+1$ 直到长度超过了原串的长度（$2^k\u0026gt;n$）。当达到限制后，每个字符开始的长度为 $2^k$ 的子串便相当于所有的后缀。并且此时肯定已经得到了互不相等的 $\\text{Rank}$ 值。\n此刻要解决的是如何排序。\n如果采用 sort 快排，时间复杂度并没有利用字符串后缀的性质。\n我们在处理长为 $2^k$ 的问题时，肯定是已经知道 $2^{k-1}$ 的 $\\text{Rank}$ 值。那我们就可以利用这些值，把一个子串 $\\text{Sub}(i,2^k)$ （从 $i$ 开始长度为 $2^k$ 的串），看作由两个关键字组成：$\\text{Sub}(i,2^{k-1})+\\text{Sub}(i+2^{k-1},2^{k-1})$。由此，可用基数排序。\n举个例子：\n以字符串“aabaaaab”为例，整个过程如图所示。其中 $x,y$ 是表示长度为 $2^k$ 的字符串的两个关键字 。\n怎么样？这个图看不懂？静下心来，细细揣摩。这里要嚼透了（尤其是 $\\text{SA},\\text{Rank}$ 数组的差别），才能理解后面更为抽象的代码实现。\n求 SA 代码具体实现\r以往很多算法都是贴个模板 code 就走人了，但今天不行。\n放一下板子，你们就明白（为什么不行）了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int sa[MAXN],rk[MAXN],oldrk[MAXN\u0026lt;\u0026lt;1],id[MAXN],key1[MAXN],cnt[MAXN]; bool cmp(int x,int y,int w) {return oldrk[x]==oldrk[y]\u0026amp;\u0026amp;oldrk[x+w]==oldrk[y+w];} void SA() { for(int i=1;i\u0026lt;=n;i++) ++cnt[rk[i]=s[i]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[rk[i]]--]=i; int p; for(int w=1;;w\u0026lt;\u0026lt;=1,m=p) { p=0; for(int i=n;i\u0026gt;=n-w+1;i--) id[++p]=i; for(int i=1;i\u0026lt;=n;i++) if(sa[i]\u0026gt;w) id[++p]=sa[i]-w; for(int i=1;i\u0026lt;=m;i++) cnt[i]=0; for(int i=1;i\u0026lt;=n;i++) ++cnt[key1[i]=rk[id[i]]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[key1[i]]--]=id[i]; for(int i=1;i\u0026lt;=n;i++) oldrk[i]=rk[i]; p=0; for(int i=1;i\u0026lt;=n;i++) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; if(p==n) break; } } 如果你能直接看懂此代码是如何求出 $\\text{SA}$ 数组——\n那么您可以直接离开此寒舍了。并接受在下一膜拜~ Orz\n如果你留了下来，别着急，我来分步讲解。\n对长度为 $1$ 的子串排序\r1 2 3 for(int i=1;i\u0026lt;=n;i++) ++cnt[rk[i]=s[i]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[rk[i]]--]=i; 第 1 行，就是把长为 $1$ 的子串（就是字符啦）全部扔进桶里。\n第 2 行，把这个桶转换成前缀和，就可以知道字符 $i$ 在原串是第几个了。\n第 3 行，由于桶内的元素也要分个排名，所以这里的写法选择了倒序循环、cnt--。\n其实这 3 行就是在做基数排序\n对长度为 $w$ 的子串排序\r先搞定第二关键字的排序\r1 2 3 p=0; for(int i=n;i\u0026gt;=n-w+1;i--) id[++p]=i; for(int i=1;i\u0026lt;=n;i++) if(sa[i]\u0026gt;w) id[++p]=sa[i]-w; 第 2 行，先把那些以自己开头，长度不足 $w$ 的 $i$ 放在排序数组 $id$ 的前端。这是因为他们根本没有第二关键字，可视为 $0$，自然是最小的。这里倒不倒序是一样的，你也可以正序写。\n第 3 行，把那些有第二关键字的，记录他们第一关键字的开头，即 sa[i]-w。\n分析一下，第 2 行的操作其实也是在记录第一关键字的开头。\n处理出新的 SA 数组\r1 2 3 4 for(int i=1;i\u0026lt;=m;i++) cnt[i]=0; for(int i=1;i\u0026lt;=n;i++) ++cnt[key1[i]=rk[id[i]]]; for(int i=1;i\u0026lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i\u0026gt;=1;i--) sa[cnt[key1[i]]--]=id[i]; 第 1 行，置空 $\\text{cnt}$，当然可以 memset(cnt,0,sizeof(cnt))。\n第 2-3 行，性质上是等价于对单个字符处理出 $\\text{SA}$ 的操作的，都是在做基数排序。这里的 key1[i]=rk[id[i]] 是一个减少访问空间来节约时间的小 Trick（因为第 4 行再次出现 key1[i]）。注意这里 $key1[i]\\neq i$，这是因为此刻的 $\\text{Rank}$ 并非此轮的新值，而是上一轮的旧值。\n第 4 行，处理出新的 $\\text{SA}$ 数组。\n根据新的 SA 得出新的 Rank\r1 2 3 4 for(int i=1;i\u0026lt;=n;i++) oldrk[i]=rk[i]; p=0; for(int i=1;i\u0026lt;=n;i++) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; if(p==n) break; 第 1 行，之所以要拷贝一份上一轮的 $\\text{Rank}$，这是因为在得到新的 $\\text{Rank}$ 时，需要上一轮的值。但是为了避免冲突，这里才会拷贝出一份。当然，代码你也可以写成 memcpy(oldrk+1,rk+1,n*sizeof(int))。\n第 2-3 行，得出新值。注意，由于 $\\text{Rank}$ 是可能有相同的，所以需要比较两个字符串是否完全相同。即 cmp(sa[i],sa[i-1],w)。\n第 4 行，由于 $p$ 表示不同的字符串的个数，所以一旦 $p=n$，意味着再没有相同的字符串，再往下做排序已不会改变 $\\text{Rank}$ 值。例如下图，第 4 次排序就是没有必要的。\nfor 循环为什么这么写？\r1 for(int w=1;;w\u0026lt;\u0026lt;=1,m=p) 变量 $w$ 代表长度，这里不多说了。至于这个 m=p，首先要明确的一点是，$m$ 表示桶可装的元素最大值。而排序后，$\\text{Rank}$ 数组中的最大值小于 $p$，所以可以改变最大值。也就是优化基数排序值域。\n一些常数优化 Trick\r第二关键字无需基数排序。正如代码中所打，按照他的实质，把无第二关键字的丢到最前面，再把剩下的依次放入。 优化基数排序的值域。代码中的 $p$ 即是 $\\text{Rank}$ 的值域，可以优化值域。 利用 $\\text{key1}$ 数组存储，减少不连续内存访问。这个在大数据效果明显。 利用 $\\text{cmp}()$ 代替计算。原理同 3。 利用指针直接交换的性质。 在 $\\text{oldrank}$ 数组拷贝时，是循环拷贝，常数较大。如果在定义时定义成指针形式，那就可以直接 t=x,x=y,y=t 进行一步交换。（但是这玩意儿很容易打错，编译器的警告也奇奇怪怪，慎用！！） 注：本贴提供的局部代码，除第 5 点外，其余 4 点均已运用。\n这个后缀数组能干什么？\r在上文，我们用了大量的篇幅来介绍什么是后缀数组、怎么代码实现求出后缀数组。那我们学会了后缀数组后，能用它解决什么问题呢？\n现在回答这个问题还为之过早。要想理解后缀数组的应用，先来了解一下 $\\text{height}$ 数组。\n什么是 $\\text{height}$ 数组\r定义 $\\text{height}[i]=\\text{lcp}(\\text{suf}(\\text{SA}[i-1]),\\text{suf}(\\text{SA}[i]))$，$\\text{lcp}(a,b)$ 即为 $a$ 和 $b$ 的最长公共前缀。\n对于 $j,k(\\text{Rank}[j]\u0026lt;\\text{Rank}[k])$，有以下性质：\n$$\r\\text{lcp}(\\text{suf}(j),\\text{suf}(k))=\\min\\{\\text{height}[\\text{Rank}[j]+1],...,\\text{height}[\\text{Rank}[k]]\\}\r$$ 以字符串 aabaaaab，求 abaaaab 和 aaab 的最长公共前缀为例：\n如何高效得到 $\\text{height}$ 数组？\r如果直接从 $\\text{height}[2]$ 计算到 $\\text{height}[n]$，时间复杂度是 $\\text{O}(n^2)$ 的。并没有利用上字符串的一些性质。\n如果我们定义数组 $\\text{h}[i]=\\text{height}[\\text{Rank}[i]]$，也就是 $\\text{suf}(i) $ 和他前一名的后缀的最长公共前缀。将有以下性质：\n$$\r\\text{h}[i]\\geq \\text{h}[i-1]-1\r$$ 考虑证明（这里借鉴了 oi-wiki）：\n如果你不想看证明，或者看不懂，可以跳到 一个方向 部分。\n当 $\\text{height}[\\text{Rank}[i-1]]\\leq 1$ 时，不等式成立（右边 $\\leq 0$）。\n当 $\\text{height}[\\text{Rank}[i-1]] \u0026gt;1$ 时：\n根据定义，转化为：\n$$\r\u003e \\text{lcp}(\\text{SA}[\\text{Rank}[i-1]],\\text{SA}[\\text{Rank}[i-1]-1]) \u003e 1\r\u003e $$ 既然 $\\text{suf}(i),\\text{suf}(\\text{SA}[\\text{Rank}[i-1]-1])$ 有长度为 $\\text{height}[\\text{Rank}[i-1]]$ 的最长公共前缀。\n不妨设这个前缀为 $aA$，即一个字符和一个长为 $\\text{height}[\\text{Rank}[i-1]]-1$ 的非空字符串。\n那么 $\\text{suf}(i-1)=aAD$，$\\text{suf}(\\text{SA}[\\text{Rank}[i-1]-1])=aAB$。（$B\u0026lt;D$，$B$ 或为空串，$D$ 非空）\n因此，$\\text{suf}(i)=AD$，$\\text{suf}(\\text{SA}[\\text{Rank}[i-1]-1]+1)=AB$。\n因为 $\\text{suf}(\\text{SA}[\\text{Rank}[i]-1])$ 在大小排名上仅比 $\\text{suf}(\\text{SA}[\\text{Rank}[i]]))$（即 $\\text{suf}(i)$）少一位，而 $AB\u0026lt;AD$。\n所以 $AB\\leq \\text{suf}(\\text{SA}[\\text{Rank}[i]-1])\u0026lt;AD$，显然 $\\text{suf}(i)$ 与 $\\text{suf}(\\text{SA}[\\text{Rank}[i]-1])$ 有公共前缀 $A$。\n于是可得，$\\text{lcp}(i,\\text{SA}[\\text{Rank}[i-1]])$ 至少是 $\\text{height}[\\text{Rank}[i-1]]-1$。\n即 $\\text{height}[\\text{Rank}[i]]\\geq \\text{height}[\\text{Rank}[i-1]]-1$。\n令 $\\text{h}[i]=\\text{height}[\\text{Rank}[i]]$，则\n$$\r\\text{h}[i]\\geq \\text{h}[i-1]-1\r\u003e $$ 证毕。\n一个方向\r得知此性质后，我们就有了明确的方向。按照 $\\text{h}[1],\u0026hellip;,\\text{h}[n]$ 的顺序计算，并利用 $\\text{h}$ 数组的性质。时间复杂度为 $\\text{O}(n)$。\n代码实现获得 $\\text{height}$ 数组\r1 2 3 4 5 6 for (i = 1, k = 0; i \u0026lt;= n; ++i) { if (rk[i] == 0) continue; if (k) --k; while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k; height[rk[i]] = k; } 这里 $k$ 不会超过 $n$，最多减 $n$ 次，所以最多加 $2n$ 次，复杂度 $\\text{O}(n)$。\n$\\text{height}$ 数组能干些什么——后缀数组算法的应用\r文章到这里，就是后缀算法的应用了。\n先简单介绍一下能应用在什么问题之上。\n最长公共前缀 单个字符串的相关问题 重复子串 字串的个数 回文子串 连续重复子串 两个字符串的相关问题 公共子串 字串的个数 多个字符串的相关问题 由于本人还没有做相关练习，这里先只介绍问题 1。其他的我先溜去做题了。\n例 1：最长公共前缀\r给定一个字符串，每次询问某两个后缀的最长公共前缀。\n分析：\r根据性质\n$$\r\\text{lcp}(\\text{suf}(j),\\text{suf}(k))=\\min\\{\\text{height}[\\text{Rank}[j]+1],...,\\text{height}[\\text{Rank}[k]]\\}\r$$ 可以将问题转化成 RMQ 问题。如果用 ST 表，那么 $\\text{O}(n\\log n)$ 预处理， $\\text{O}(1)$ 查询。\n如果用 $\\text{O}(n)$ 预处理 RMQ 问题，那么本题可以做到 $\\text{O}(n)$。（虽然作者不会 $\\text{O}(n)$ 预处理）\n参考文献\r[1] 罗穗骞，IOI2009 国家集训队论文《后缀数组——处理字符串的有力工具》\n[2] OI-Wiki，《后缀数组简介》\n[3] YxuanwKeith，《五分钟搞懂后缀数组！后缀数组解析以及应用(附详解代码)》\n结尾\r这篇笔记写得匆匆忙忙，昨天晚修开始写，写到今天早上。\n有错误时不可避免的，欢迎读者指出我的错误。如有疑问或高见，也可以评论。\n由于一上完课就来写笔记，还没做多少题目，这里只讲了最长公共前缀的算法分析，实在抱歉。\n本人版权意识薄弱，如有侵权部分，请联系作者解决。\n希望这篇笔记能帮到你，Thank you~\n","date":"2024-01-14T22:00:00+08:00","image":"https://werchange.github.io/img/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/p1.png","permalink":"https://werchange.github.io/p/%E8%B6%85%E7%BA%A7%E7%AE%80%E5%8D%95%E7%9A%84%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84sa/","title":"超级简单的后缀数组（SA）！！"},{"content":"题目跳转\nFake_Solution\r前言\r[warning]: 本题解的做法是错法，但是正确概率贼高。离谱的是正确率还可以叠加。\n正解是记搜，时间复杂度可以证明。正解看文末。\n思考\r众所周知一个公式：\n$$\ra\\times b=\\operatorname{lcm}(a,b)\\times \\gcd(a,b)\r$$ 如果你不知道——自证吧，不难。\n于是，移一下项可得\n$$\r\\operatorname{lcm}(a,b)=\\frac{ab}{\\gcd(a,b)}\r$$ 那本题就是求这个玩意儿（设 $g(a,b)=\\gcd(a,b)$， $g(X)=g(x_1,\\dots,x_n)$）\n$$\r\\frac{g(X)\\times g(Y)}{g(g(X),g(Y))}\r$$ 关键是，我们怎么求得这个分数呢？\n观察一手分母，实际上就是\n$$\rg(g(x_1,\\dots,x_m),g(x_1,\\dots,x_m))\\\\\\Downarrow\\\\g(x_1,\\dots,x_m,y_1,\\dots,y_m)\\\\\\Downarrow\\\\g(a_1,\\dots,a_n)\r$$ 也就是说无论怎么放置卡片，分母是始终不变的。都可以根据给出的值求得。\n分子怎么办呢？\n由于是 $g(X)\\times g(Y)$，我们可以试着贪心去取较大值。然后一路 $O(n)$ 下去就好了。\n但是会有问题（极小概率），给个 hack。\n1 2 3 4 3 7175 27378 9184 26427 29992 7190 但是，数据出现这种卡贪心的情况概率极低。Atcoder 的 70 组数据也就一组。\n为了提高正确率，我们可以倒着再跑一次。\n是的，你没听错，就是贪心 + 乱搞。\n代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 50 + 5; int n; int a[MAXN], b[MAXN]; int solve() { int x = a[1], y = b[1]; for (int i = 2; i \u0026lt;= n; i++) { int nx = __gcd(x, a[i]); int ny = __gcd(y, b[i]); int mx = __gcd(x, b[i]); int my = __gcd(y, a[i]); if (nx * ny \u0026gt; mx * my) x = nx, y = ny; else x = mx, y = my; } return x * y / gcd(x, y); } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); int ans1 = solve(); for (int i = 1, j = n; i \u0026lt;= j; i++, j--) swap(a[i], a[j]), swap(b[i], b[j]); int ans2 = solve(); printf(\u0026#34;%lld\\n\u0026#34;, max(ans1, ans2)); return 0; } Solution\r还是补一个正解做法。其实直接记忆化爆搜就好了，时间复杂度可以证明通过本题限制~~（虽然我不会）~~。\n代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 50 + 5; int n; int a[MAXN], b[MAXN]; struct node { int x, ga, gb; node(int a = 0, int b = 0, int c = 0) { x = a; ga = b; gb = c; } bool operator\u0026lt;(const node \u0026amp;T) const { if (x != T.x) return x \u0026lt; T.x; if (ga != T.ga) return ga \u0026lt; T.ga; return gb \u0026lt; T.gb; } }; int ans; map\u0026lt;node, bool\u0026gt; vis; int lcm(int a, int b) { return a * b / __gcd(a, b); } void dfs(int x, int ga, int gb) { if (vis[node(x, ga, gb)]) return; vis[node(x, ga, gb)] = 1; if (x == n + 1) { ans = max(ans, lcm(ga, gb)); return; } dfs(x + 1, __gcd(ga, a[x]), __gcd(gb, b[x])); dfs(x + 1, __gcd(ga, b[x]), __gcd(gb, a[x])); } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); dfs(2, a[1], b[1]); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2023-12-16T11:48:00+08:00","permalink":"https://werchange.github.io/p/arc124c-lcm-of-gcds-%E9%A2%98%E8%A7%A3/","title":"[ARC124C] LCM of GCDs 题解"},{"content":"提供二分+DP做法。\nSolution\r题意\r给出 $n(\\le 2\\times 10^5)$ 个单调递增偶整数 $a_i$，求最小的 $k$ 满足每一个 $i$ 都可以在 $k$ 时刻之前（含）与相邻的数相遇。每个单位时间可以移动一个单位距离。\n思路\r启发式思考\r在想到正解之前，我们可以想想类正解。\n显然，在时间一单位一单位过去的时候，一个元素如果愣着不动，肯定不是最优的策略——因为无论它去追随相邻的、或是去相遇相邻的，时间都可以尽可能更优。\n所以我们看做元素是不断运动的。\n如果它乱走，没有遇到任意一个相邻的元素的情况下，随便改变方向，好像也不优。所以我们也规定一个元素就只有两个阶段：第一、第二阶段——要么先左再右，要么先右再左。\n想到这里，对我们有了些许启发。来看看下面这个能拿 80pts 的错解：\n就考虑两种情况：\n奇（ji）左偶右：黑色表示第一阶段、红色表示第二阶段 奇（ji）右偶左：同上 当然 $n$ 的奇偶也要考虑。\n像这样，是不是以为可以直接 $O(n)$ 直接跑就解决了？\n显然，这太天真了 （像我一样） ，提供一组 hack 数据：\ninput\r1 2 10 12 12 24 26 56 70 98 124 124 178 answer\r1 34 output\r1 36 至于模拟过程自己模拟吧，这是我能对出来的最小数据了。\n贴一个错误代码，可以自己对拍对数据。\n正解\r我们可以直接二分答案 $k$。\n接下来考虑怎么扩缩范围。\n设 $f(i,0)$ 表示元素 $i$ 先左走，调头后最多还可走多少步。\n设 $f(i,1)$ 表示元素 $i$ 先右走，最多可以走多少步再掉头。\n然后就是小学学过的相遇问题，自己在纸上画画就出来了，这里不做赘述。要是不会的话，可以私信。\n方程不好整理 （因为我懒） 自己看代码吧。挺具象的。\n代码\r马蜂抽象就随便看看吧，溜了\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 2e5 + 5; int n; int a[MAXN]; int d[MAXN]; int f[MAXN][2]; bool check(int md) { memset(f, -1, sizeof(f)); f[1][1] = md; for (int i = 2; i \u0026lt;= n; i++) { if (f[i - 1][1] != -1) { int k = f[i - 1][1]; if (k - d[i] / 2 \u0026gt;= 0) { f[i][0] = max(f[i][0], md - d[i] / 2); f[i][1] = max(f[i][1], k - d[i] / 2); } } if (f[i - 1][0] != -1) { int k = f[i - 1][0]; if (k - d[i] / 2 \u0026gt;= 0) { f[i][0] = max(f[i][0], k - d[i] / 2); f[i][1] = max(f[i][1], k - d[i] / 2); } } } return f[n][0] != -1 || f[n][1] != -1; } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); for (int i = 2; i \u0026lt;= n; i++) d[i] = a[i] - a[i - 1]; int l = 1, r = 1e9, mid, ans = -1; while (l \u0026lt;= r) { mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid - 1, ans = mid; else l = mid + 1; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2023-12-04T20:14:00+08:00","permalink":"https://werchange.github.io/p/arc120e-1d-party-%E9%A2%98%E8%A7%A3/","title":"[ARC120E] 1D Party 题解"},{"content":"题解\r前言\r个人认为官方题解写得最为详细、干净、清楚，如果有意向阅读外文版的题解的话，还是推荐去读一读：\nEditorial - AtCoder Regular Contest 117\n本文属于转载（？），有一些自己的思考过程，希望有帮助。\n题意\r有多少个长度为 $2N$ 的序列 $A$ 满足：\n序列$A$ 包含 $N$ 个 $+1$ 和 $N$ 个 $-1$。 刚好有 $K$ 对下标 $l,r(1\\leq l\u0026lt;r\\leq 2N)$，满足 $\\sum\\limits_{i=l}^{r} = 0$，我们把形如 $[l,r]$ 这样的区间称为“零和区间”。 给出 $N,K$，求满足条件的序列个数。\n$1\\leq N\\leq 30,1\\leq K\\leq N^2$。\n分析\rPart 1\r我们考虑用最暴力的做法，那就是二进制枚举 $A$ 的状态。然后枚举 $l,r$ 采用前缀和相减判断是否为零和区间。\n时间复杂度：$O(2^n)$，预计：34 pts。\nPart 2\r显然 Part 1 的做法超时，那我们能不能得到一些启发呢？\n显然是前缀和。\n我们期望得到的是 $sum_r-sum_{l-1}=0$，实际上，我们也就是想得到 $sum_r=sum_{l-1}$。由于原数组为 $\\pm 1$，所以当我们把前缀和数组看做是关于 $i$ 的函数 $sum_i$ 的话，得到的图像，必定是每一段都为 45° 的折线图。而起点与终点都将是 $0$。\n我们可以想象一条 $y=k$ 的一条横线从上往下扫。我们就可以分别考虑放置所有二维平面上的点了。\n我们发现两个相等且“相邻”的元素之前是可以放下一个或多个更小的元素的。“相邻”怎么解释？“相邻”代表着当只考虑当前的元素 $y$ 与大于 $y$ 的元素时，如果两个元素 $y$ 之间没有再多一个元素 时，则称之为“相邻”。我们把“相邻”的元素之间的空隙，称之为“洞”。\n如果考虑到当前这个“洞”（下文不再加括号），我们先考虑当前要放的元素都是相同的值。\n那就可以自然地想到采用 dp。\n设 $f[x][y][z]$ 表示放了 $x$ 个元素，得到了 $y$ 个零和区间，还有 $z$ 个洞的方案数。\n如何转移？设当前放进洞里的元素数量为 $p$，则转移方程为：\n$$\rf[x][y][z]\\to f[x+p][y+C_p^2][p-(z+2)]\r$$ $$\\Downarrow$$ $$\rf[x][y][z]\\to f[x+p][y+\\frac{p\\times(p-1)}{2}][p-(z+2)]\r$$ 为什么剩下的洞的数量是 $p-(z+2)$ 呢？因为原来有 $z$ 个洞，每个洞需要放一个元素，同时最左边与最右边又需要各放一个元素，就共放了 $z+2$ 个元素。\n在此基础上，每多放一个元素，就可以多增加一个洞。自然就是 $p-(z+2)$。\n值得一提的是，上式并没有采用等号连接，因为方程还需要再乘上一个 $C_{p-1}^{z+1}$（读者自证）。所以方程应该是这样：\n设 $x\u0026rsquo;=x+p,y\u0026rsquo;=y+\\frac{p(p-1)}{2},z\u0026rsquo;=p-(z+2)$，则\n$$\rf[x'][y'][z']=\\sum\\limits_{x,y,z} f[x][y][z]\\times C_{p-1}^{z+1}\r$$ 最后答案需要记录 $x$ 轴上、下方的贡献，总共就是\n$$\rans=\\sum\\limits_{x,y,z} f[x][y][z]\\times f[2n-x][k-y][z-1]\r$$ 至于为什么是 $z-1$ 呢？这个显然，请读者联系一下上图思考。（提示，$x$ 轴下方可以翻转过来相似地考虑。）\n到这里就结束了，可以开码了。\n时空复杂度：$O(n^5)$，预计：100 pts。\n代码\r马蜂有点抽象，将就看看吧（\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 60 + 5, MAXM = 1800 + 5; int n, m; int f[MAXN][MAXM][MAXN]; int ans; int c[2 * MAXN + 5][2 * MAXN + 5]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt;= 2 * n; i++) { c[i][0] = 1; for (int j = 1; j \u0026lt;= i; j++) { if (j != i) c[i][j] += c[i - 1][j]; c[i][j] += c[i - 1][j - 1]; } } for (int i = 1; i \u0026lt;= n + 1 \u0026amp;\u0026amp; i * (i - 1) / 2 \u0026lt;= m; i++) f[i][i * (i - 1) / 2][i - 1] = 1; for (int i = 1; i \u0026lt;= 2 * n + 1; i++) { for (int j = 0; j \u0026lt;= m; j++) { for (int k = 0; k \u0026lt;= n; k++) { if (f[i][j][k] == 0) continue; for (int p = k + 2; i + p \u0026lt;= 2 * n + 1 \u0026amp;\u0026amp; p \u0026lt;= n + 1; p++) { if (j + p * (p - 1) / 2 \u0026gt; m) break; f[i + p][j + p * (p - 1) / 2][p - (k + 2)] += f[i][j][k] * c[p - 1][k + 1]; } } } } ans = f[2 * n + 1][m][0]; for (int i = 0; i \u0026lt;= 2 * n + 1; i++) { for (int j = 0; j \u0026lt;= m; j++) { for (int k = 1; k \u0026lt;= n; k++) { ans += f[i][j][k] * f[2 * n + 1 - i][m - j][k - 1]; } } } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2023-11-24T17:28:00+08:00","permalink":"https://werchange.github.io/p/arc117e-zero-sum-ranges-2%E9%A2%98%E8%A7%A3/","title":"[ARC117E] Zero-Sum Ranges 2题解"},{"content":"Success Rate\n（提供二分做法）\n前言\r听说是史上最简单蓝题，做了一下。\n题意\r已知 $x,y,p,q$，通过只让 $y$ 加 $1$ 或 $x,y$ 同时加 $1$，使得满足： $$\r\\frac{x'}{y'}=\\frac{p}{q}\r$$ 思考\r目标状态为 $\\frac{p}{q}$，考虑到这是个比值，自然 $\\frac{x\u0026rsquo;}{y\u0026rsquo;}=\\frac{kp}{kp}$。\n明显地，这里的 $k$ 如果合法，那就一定有更小的 $k$。\n所以考虑二分。\n限制条件呢？\n因为无论如何决策，$y$ 都会加 $1$；而 $x$ 不一定每一次决策都加 $1$。即 $\\Delta y\\geq \\Delta x$。\n所以保证 $\\Delta x \\leq \\Delta y$ 就好了。即 $kp-x\\leq kq-y$。\n需要注意的是，有一点需要特判：\n$p=0$ 时 $x\u0026gt; 0$，输出 $-1$ $x=0$，输出 $0$ 代码\r考虑到数据范围均小于 $10^9$，所以右端点不可以取太大，否则越界变成负数，右端点取 $10^{10}$，开个 long long 就好了。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int x,y,p,q; bool check(int md) { return p*md-x\u0026lt;=q*md-y \u0026amp;\u0026amp; p*md\u0026gt;=x; } void solve() { scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;p,\u0026amp;q); if(p==0) { if(x) puts(\u0026#34;-1\u0026#34;); else puts(\u0026#34;0\u0026#34;); return; } int l=1,r=1e10,mid,ans=-1; while(l\u0026lt;=r) { mid=l+r\u0026gt;\u0026gt;1; if(check(mid)) r=mid-1,ans=mid; else l=mid+1; } if(ans==-1) puts(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;,ans*q-y); } signed main() { signed T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) solve(); return 0; } ","date":"2023-11-02T20:10:00+08:00","permalink":"https://werchange.github.io/p/cf773a-success-rate-%E9%A2%98%E8%A7%A3/","title":"CF773A Success Rate 题解"},{"content":"CSP2023 总结\r前言\r这次 CSP2023 并没有考出水平。经过深刻反思，我总结了个人目前存在的一些问题与改进的方案。\n上午 CSP-J\r开始后，手忙脚乱地建好了目录文件、配置好了 DEV-C++ 的语法环境、切换好了 ENG 输入法。\nT1\r看到 T1 发现不如去年简单，有些慌张。\n努力冷静下来后，推了一下，就得出了结论，码完之后测了大样例，都过了。还是不放心，又搓了几手小数据，没什么问题，检查完文操后就过了。\n但是由于第一题的小心检查，不仅耗去了不少时间，也使得接下来我陷入了“小心猜想”的怪圈。\nT2\rT2 是今年最遗憾的一题。不是因为不会做、没做出来，而是因为在 T2 消耗了太多时间。\n本应是很快就应该切掉的一题，我却复杂化了题目。\n第一遍猜想时，其实就想到了贪心正解。但是我陷入了“小心猜想、大胆求证”的错误思维怪圈，导致当时不知为什么就直接否了这个猜想。\n过程中跑去看了 T3,T4。\n后面不知过了多久重新读一遍题时，才反应过来这题被我复杂化了。\n此时时间已经超出了我对切 T1,T2 的计划。\nT3\r与去年一样，T3 还是大模拟。一看到还是有信心的，毕竟这题用不着太多思考，尤其是在已经消耗了太多时间的情况下。\n码完之后大样例没过，小调一手就都过了。搓了两组很小的小数据。匆匆检查完文操后就跳了 T4。\nT4\r看到 T4 的时候已经没有时间思考了。虽然卡在 T2 的时候看了一眼题面，但是没有思考过。\n思考一会儿后，只得到一些小性质。\n现在我还有 3 个选择：\n跑去完整检查一遍 T1,T2,T3 ，放弃 T4。 死磕 T4，相信之前的“平推检查”。 打 T4 部分分，再返回检查文操等细节问题 本来我是想着选择死磕，如果前面一分不挂、今年 T4 像去年一样简单，那我的检查就没有效益。\n但是出于之前模拟赛的经验，我知道这种压力环境下是很难想的。所以我选择了放弃 AK 梦。\n我决定看着数据范围打拼盘。（相信数据！）\n由于样例都没有特殊性质的数据，自己搓了一些，打了文操就过了。\n估分\r$100+100+80+5=285$\nT3 是 T 了两个点，我觉得应该是有一部分卡死了。可惜的是，考场上没有检查 T3 代码，只检查了细节。T4 不知道实际到底能骗多少分，应该不止 5 分。\n下午 CSP-S\r下午开始前，整个人的状态是很好的，好到有些飘。因为自以为拿了 300+ pts，所以莫名信心++。为后面“暴毙”埋下伏笔。\n开始后，有了上午的经验，飞快地完成了硬性要求操作。开始读题。\nT1\r简单看了两眼，有点难。\n再看一眼，怎么就 5 位密码？\n再看一眼数据，$n\\leq 8$，直接 $O(10^5n)$ 走起！\n飞快地打完了，再次严谨地检查了时间复杂度，确认不会 T，检查完文操、搓了一手数据后跑路。\nT2\r区间？试一下线段树/分治。\n思考了很久，不知道怎么处理两个区间相邻部分。赛后听 cjx 说是 cdq 分治。没学，幸好当时没有继续往分治想。\n现在看我的代码，我已经说不清当时怎么想的了。总之糊了一个类似正确的做法。\n一测大样例，直接错误。\n由于大样例很大，很难判断，我尽可能的举出小并且能证伪的数据。幸运的是举了几个出来、答案也越来越接近大样例的 .ans；不幸的是，再往后就举不出来了，可是始终有两个大样例过不了。\n此时时间已经超过预计了。按理，我不会 T，是 WA，但是有些数据下是可以过的、不会 0 pts，例如大样例3 就惊奇的被我糊过了。所以我应该跳题。去打部分分。\n但是，出于上午 J组的自信。我做了最愚蠢的决定——死磕 T2。\n这一死磕，就真的是没有尽头了。\n等我反应过来的时候，想上个厕所冷静一下。上厕所的人很多，我抬头看了一眼，总有人进进出出。我想我是排不到了，所以没有申请上厕所。但是我注意到，外面的天都已经黑了。——我慌了。\n我犹豫过，要不要跳 T3，我看到一眼就知道了是大模拟。但是我执迷不悟，看了一眼后不打算跳。T4 我题目都没看懂（匆匆看了两眼），想起去年最后一题是紫题，所以没有勇气去花时间看懂。\n但是最后我慌了，要是再打不出来，200+ pts 是无望了。一等也就无望了。我选择认怂。\n跳题。\nT3\r看了题目，按理来说照着题面打就能打A。毕竟是大模拟。但是我连看懂题目的时间也没有了。我清楚这道题是要丢了。\n看到 opt 4 有无解情况。又有了去年“总司令”的经验，那就试试。即使这次的数据全部输出无解情况非常渺茫，但总比 0 pts 好。\nT4\r随便看了一眼，输出了 $n+1$。打上文操，回去检查。\n估分\r洛谷：$100+25+0+0=125$\n小图灵：$100+35+0+0=135$\n今年 S组是我第一次打进 S组复赛，所以没有任何经验。\n但是今年我看是没有奇迹般的一等了。\n总结\r两场都没有发挥好。\nJ组：反映出来我很容易陷入“小心猜想、大胆求证”的惰性思维。不勤于思考。\nS组：反映出来我策略不当、心里防线薄弱。很容易因处境改变心里想法。\n以上也都反映了最近乃至前段时间我模拟赛成绩垫底的原因——不勤于思考、总是随便推翻自己却又找不到严谨理由、心里防线薄弱、心态崩溃后大脑宕机。\n计划\r不能一味地批判，要提建设性计划。\n改变思考方式，大胆猜想、小心求证。 多于思考，勤于思考，善于思考。 调整考试策略，找到合适自己的思考时间与代码实现时间。 要善于调整合理心理状态、建设强大的心理防线。 总结经验，相同错误不犯第二遍。 End\r今年是有遗憾的。\n最后一年 J组破碎了 AK梦。\n初三的 S组不见了一等梦。\nNOIP2023 估计是没机会去了。今年的赛季也大多与我无关了。\n夯实基础、勤学善思，明年还是有很大机会的！\n查分\rCSP-J：$100+100+100+0=300$，一等。\nCSP-S：$100+30+0+0=130$，二等。\n寄了，135pts才能去NOIP，150pts才有一等。。\n赛季报销。。\n","date":"2023-10-28T16:27:00+08:00","permalink":"https://werchange.github.io/p/csp2023-%E6%80%BB%E7%BB%93/","title":"CSP2023 总结"},{"content":"题意很清晰，直接跑 SPFA 求最短路。\n只是我们在松弛操作时，需要注意从 $u$ 是否可以到达 $v$。\n怎么判断呢？\n请移步下面三个部分。\nPart 1\r先解释一下，下面点 $i$ 的信息分别为以下变量：\ncolor 表示颜色， 1 表示蓝色，0 表示紫色 num 表示初始状态持续时间 t1 表示蓝色状态持续时间 t2 表示紫色状态持续时间 我们写一个函数 getcolor(int i,int tim)，表示点 $i$ 在 $tim$ 时刻的下一个颜色状态是什么。\n分一下情况：\n$tim\u0026lt;num[i]$，直接返回 color[i]^1。 $tim\\geq num[i]$ $color[i]$ 为紫色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t1[i]$，返回 color[i]。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t1[i]$，返回 color[i]^1。 $color[i]$ 为蓝色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t2[i]$，返回 color[i]。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t2[i]$，返回 color[i]^1。 code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool getcolor(int i,int tim) { bool color=a[i].color^1; if(tim\u0026lt;a[i].num) return color; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return color^1; return color; } else { if(tim\u0026lt;a[i].t2) return color^1; return color; } } Part 2\r得到一个函数，仅仅只能求第 $tim$ 时刻的下一个颜色状态是远远不够的。\n我们还需要与这个函数类似功能的函数 gettim(int i,int tim)。\n意义为：\n得到一个值，这个值表示点 $i$ 在 $tim$ 时刻变成下一个状态还需要多少时间。\n与上一 Part 类似的，可以分讨一下：\n$tim\u0026lt;num[i]$，直接返回 num[i]-tim。 $tim\\geq num[i]$ $color[i]$ 为紫色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t1[i]$，返回 t1[i]-tim。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t1[i]$，返回 t1[i]+t2[i]-tim。 $color[i]$ 为蓝色 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\u0026lt;t2[i]$，返回 t2[i]-tim。 $(tim-num[i])\\mod \\ (t1[i]+t2[i])\\geq t2[i]$，返回 t1[i]+t2[i]-tim。 代码也很类似。\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int gettim(int i,int tim) { if(tim\u0026lt;a[i].num) return a[i].num-tim; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return a[i].t1-tim; return a[i].t1+a[i].t2-tim; } else { if(tim\u0026lt;a[i].t2) return a[i].t2-tim; return a[i].t1+a[i].t2-tim; } } Part 3\r得到了这两个函数，一切都变得简单多啦~\n现在思考在松弛中面对 $u$ 和 $v$ 两个点时的情况。\n先是用变量 cu 和 cv 分别表示 $u$ 的下一个颜色与 $v$ 的下一个颜色。\n如果 $cu=cv$，直接松弛。 如果 $cu\\neq cv$，多拿一个变量 tmp 负责接下来记录要等待多少时间才能从 $u$ 走到 $v$。 现在讨论 $cu\\neq cv$ 的情况。\n先分别得到 $u$ 和 $v$ 变成下一个状态所需要的时间 tu 和 tv。\n如果 $tu=tv$，则 tmp=min(tu,tv)。 如果 $tu\\neq tv$，说明接下来要看周期性的颜色变换是否可以让 $u$ 走到 $v$。 现在讨论周期性的颜色变换。\n由于是周期性的，所以如果 $u$ 注定永远走不到 $v$，说明它们的周期总是交叉相等。\n什么意思呢？举个例子。\n1 2 u: B 6 10 70 v: P 6 70 10 上面这两个点，总是同时变换状态，所以永远不能到达。所以我们判断周期是否交叉相等就可以筛掉无法到达的情况。直接 continue 松弛下一个 $v\u0026rsquo;$。\n那接下来就注定可以到达，直接分讨一下就可以得到 tmp 了。\ntmp 一出，有手就行。只需要在松弛的判断中加上一个 tmp 就好了。\n代码\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=400+5,MAXM=14000+5,INF=1e18; int s,t; int n,m; int su,hd[MAXN],vl[MAXM\u0026lt;\u0026lt;1],lt[MAXM\u0026lt;\u0026lt;1],en[MAXM\u0026lt;\u0026lt;1]; int dis[MAXN]; bool vis[MAXN]; struct node { bool color; int num,t1,t2; }a[MAXN]; void add(int u,int v,int w) { en[++su]=v,vl[su]=w,lt[su]=hd[u],hd[u]=su; } bool getcolor(int i,int tim) { bool color=a[i].color^1; if(tim\u0026lt;a[i].num) return color; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return color^1; return color; } else { if(tim\u0026lt;a[i].t2) return color^1; return color; } } int gettim(int i,int tim) { if(tim\u0026lt;a[i].num) return a[i].num-tim; tim-=a[i].num; tim%=(a[i].t1+a[i].t2); if(a[i].color==0) { if(tim\u0026lt;a[i].t1) return a[i].t1-tim; return a[i].t1+a[i].t2-tim; } else { if(tim\u0026lt;a[i].t2) return a[i].t2-tim; return a[i].t1+a[i].t2-tim; } } void SPFA() { for(int i=1;i\u0026lt;=n;i++) dis[i]=INF; queue\u0026lt;int\u0026gt; q; q.push(s); vis[s]=1,dis[s]=0; while(!q.empty()) { int u=q.front();q.pop(); for(int i=hd[u];i;i=lt[i]) { int v=en[i]; int tmp=0; bool cu=getcolor(u,dis[u]); bool cv=getcolor(v,dis[u]); if(cu^cv) { int tu=gettim(u,dis[u]); int tv=gettim(v,dis[u]); // simple turn once if(tu==tv) // hard turn more { if(a[u].t2==a[v].t1\u0026amp;\u0026amp;a[u].t1==a[v].t2) continue; if(cu==0) // now u is purple { if(a[u].t2==a[v].t1) tmp=a[u].t2+min(a[u].t1,a[v].t2); else tmp=min(a[u].t2,a[v].t1); } else // now u is blue { if(a[u].t1==a[v].t2) tmp=a[u].t1+min(a[u].t2,a[v].t1); else tmp=min(a[u].t1,a[v].t2); } tmp+=tu; } else tmp=min(tu,tv); } if(dis[v]\u0026gt;dis[u]+tmp+vl[i]) { dis[v]=dis[u]+tmp+vl[i]; if(!vis[v]) vis[v]=1,q.push(v); } } vis[u]=0; } } signed main() { scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,\u0026amp;s,\u0026amp;t,\u0026amp;n,\u0026amp;m); for(int i=1,num,t1,t2;i\u0026lt;=n;i++) { char ch; scanf(\u0026#34;%s%lld%lld%lld\u0026#34;,\u0026amp;ch,\u0026amp;num,\u0026amp;t1,\u0026amp;t2); a[i]={(ch==\u0026#39;B\u0026#39;),num,t1,t2}; } for(int i=1,u,v,w;i\u0026lt;=m;i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v,w); add(v,u,w); } SPFA(); if(dis[t]==INF) dis[t]=0; printf(\u0026#34;%lld\\n\u0026#34;,dis[t]); return 0; } ","date":"2023-08-22T21:12:00+08:00","permalink":"https://werchange.github.io/p/usaco-jan-2011%E4%BA%A4%E9%80%9A%E7%81%AF-%E9%A2%98%E8%A7%A3/","title":"[USACO JAN 2011]交通灯 题解"},{"content":"01 分数规划\r什么是 01 分数规划\r用人话说，就是：\n有 $n$ 个玩意儿，每个都有两个属性 $(x,y)$。现在要从中选出几个玩意儿，使得 $\\frac{\\sum x}{\\sum y}$ 最大\n但是有些人仍然不懂。没关系，可以用数学语言表示：\n有三个序列 $x,y,z$ 长度为 $n$。\n$z$ 满足 $\\forall i\\in [1,n],z_i\\in(1,0)$\n然后得到一种合法的 $z$ 的取值，最大化： $$\\frac{\\sum\\limits_{i=1}^{n} x_i\\times z_i}{\\sum\\limits_{i=1}^{n} y_i\\times z_i}$$ 怎么解这个问题\r解法：二分法。\n首先先转移：\n令 $L=\\frac{\\sum\\limits_{i=1}^{n} x_i\\times z_i}{\\sum\\limits_{i=1}^{n} y_i\\times z_i}$， 则 $$\rL\\times \\sum\\limits_{i=1}^{n} y_i\\times z_i=\\sum\\limits_{i=1}^{n} x_i\\times z_i \\\\\r\\Downarrow\\\\\r\\sum\\limits_{i=1}^{n} x_i\\times z_i-L\\times \\sum\\limits_{i=1}^{n} y_i\\times z_i=0 \\\\\r\\Downarrow\\\\\r\\sum\\limits_{i=1}^{n} (x_i-y_i\\times L)\\times z_i=0\r$$ 相当于拥有了一个数组 $a,a_i=x_i-y_i\\times L$，从$a$中选一些数使得总和最大。\n显然，选择所有的正数即可。\n这个 $L$ 就是二分中的 $mid$ 了。\n由于这个 $L$ 是二分得到的，所以每一次不一定都是 $$\\sum\\limits_{i=1}^{n} (x_i-y_i\\times L)\\times z_i=0$$ 而是 $$\\sum\\limits_{i=1}^{n} (x_i-y_i\\times L)\\times z_i\\geq0$$ 也就是在代码的二分中判断此刻的 $mid$ 可不可行时，在 if 里面写上这个。\n板题\r这个不算很板的题目，贴一下吧。 P4377 [USACO18OPEN] Talent Show G\n这里附一份代码：\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=1e5+5; const double eps=1e-6; int n,W; int w[MAXN],t[MAXN],maxz; double a[MAXN]; double f[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;W); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;w[i],\u0026amp;t[i]),maxz+=t[i]; double l=0,r=maxz; while(r-l\u0026gt;eps) { double mid=(l+r)/2; for(int i=1;i\u0026lt;=n;i++) a[i]=t[i]-w[i]*mid; for(int i=1;i\u0026lt;=W;i++) f[i]=-1e9; for(int i=0;i\u0026lt;=n;i++) { for(int j=W;j\u0026gt;=0;j--) f[min(j+w[i],W)]=max(f[min(j+w[i],W)],f[j]+a[i]); } if(f[W]\u0026gt;=eps) l=mid; else r=mid-eps; } printf(\u0026#34;%lld\\n\u0026#34;,(int)floor(1000*l)); return 0; } ","date":"2023-08-14T21:07:00+08:00","permalink":"https://werchange.github.io/p/01-%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","title":"01 分数规划"},{"content":"提供一种思路，可以做到 $O(n)$。\nupdate 2023.08.13 修改了 Latex 滥用问题。\nupdate 2023.08.12 修改了空格问题。\nupdate 2023.08.11 修改了空格问题。\nupdate 2023.07.29 完工，期望无 bug （暑假快乐吖）\nupdate 2023.07.27 （要原题检测了，先占个坑，有时间再补）\n原题大意\r有 $n$ 张牌，每次取出 $m ;(m\u0026lt;n)$ 张牌进行置换操作。操作完一轮后会出第 $1$ 张牌，并再加入 $1$ 张牌继续进行新一轮的置换操作。\n最后无法再进行操作时，则按现顺序不断出牌。\n求倒数第 $x$ 次出牌的原编号是多少。\n暴力解法\r如果没有思考直接开码的话，得到的暴力代码是 $O(nq)$ 的。这个时间复杂度 2013 年的老机器是过不了的。\n预计： 73pts\n倍增解法\r这是正解的一种。通过倍增优化后，时间复杂度是 $O(n \\log n)$。\n此处不展开讲倍增解法，原因有三：\n本题已有大量倍增解法的题解。 虽然是 $O(n \\log n)$，可以通过本题，但还不是最优解，本帖主要讲最优解 $O(n)$ 做法。 本人只会不熟练的运用倍增求 LCA 问题（虽然现在还是用树链剖分求 LCA ），倍增还能优化是我听教练讲解后才知道的。 预计： 100pts\n$O(n)$ 解法\r[warning]： 前方请准备好草稿纸，有演算过程……\nPart 0 思考性质\r首先我们考虑普通的置换。\n例如下面的这个情景：\n有 5 个学生要换位置。\n原位置： $$1\\;2\\;3\\;4\\;5$$ 目标位置： $$4\\;3\\;1\\;5\\;2$$ 推论：如果我们把原位置上的数与目标位置上的数进行建边，会得到一些（可能一个）环或点。\n如上例： $$1\\to 4\\to 5\\to 2\\to 3\\to 1$$ 多举几个例子，会发现都符合推论。\n那我们再来看本题的置换。\n但是本题的置换有一个很大的特色——每次置换后都会推出第 $1$ 个数，加入第 $m+1$ 个数。\n这样的特色带来了一个性质：那就是本题置换不会出现环，只会出现链。\n为什么呢？因为有一个都被推出了，相当于下一次的置换就再也找不到那一个。因此不会形成环。\n那现在，就对我们的置换操作，来分些 Part 吧。\nPart 1 “直接走”操作\r为什么叫“直接走”？这个操作用来得到被推出来的 $n-m+1$ 张牌。\n$n-m+1$ 是因为最多只会做 $n-m+1$ 次置换。\n因此，可以用 dfs 染色的方法先把含$1$的链得出。那么按 dfs 顺序得到的一些 $x_i$ 代表着正数第 $i$ 次原编号为 $x$ 的牌就被推出了。\n但是要一点要注意，因为有的时候置换的操作不多，所以可能有一些残留的、与答案不符的。\n所以需要做个判断，假设得到的 $x$ 数组长度为 $len$。\n若 $len\u0026lt; n-m+1$，则将 $x_i$ 其中 $i\\in [1,len]$ 一个一个地压入答案的 $ans[]$ 数组里。 否则，直接将 $i\\in [1,n-m+1]$ 的所有 $x_i$ 压入 $ans[]$ 即可。 但是，第一种情况时，还有一些 $(n-m+1-len)$ 的元素还没压入怎么办？如何考虑这些元素？\n请移步 Part 2\nPart 2 “直接走没走完”操作\r这里，我们如何思考？\n考场上，可以通过打表法来观察。即我们手搓样例，再模拟出牌过程。\n[warning]： 如果你不想思考、不想自己动手，可以直接跳到一个结论部分。\n这里可以提供一组样例，十分建议大家手搓一下：\n输入\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 10 5 10 4 1 3 5 2 10 9 8 7 6 5 4 3 2 1 输出\r1 2 3 4 5 6 7 8 9 10 2 3 1 5 6 7 10 8 9 4 这个样例，是属于“直接走没走完”的情况。因为含 $1$ 的链，只有 $$2\\to 3\\to 1\\to 5$$ 这也正是样例输出的前四个。\n但是 $n-m+1=10-5+1=6$，现在只得到了“直接走”部分的前 $4$ 个，还有俩没输出呢，怎么办？\n仔细看看样例输出，$6$ 和 $7$ 是接下来的这俩。\n有啥规律吗？如果你再多搓几组样例，就会发现一个结论。\n一个结论\r$$\rx_i=m+i\\;\\;\\;\\;\\; i\\in [len+1,n-m+1-len]\r$$ 但是道理是什么？\n因为我们这 $m$ 个位置的置换可以分成两部分：\n从入口 $0$ 到 $m$ 的一条链（路径） 其余部分 而这个其余部分是各种大小不一的环，而置换后，本质上数的位置就是环中不断变换的位置。\n结论已出，那此 Part 结束。现在，我们剑指 Part 3。\nPart 3 “走不完”操作\r为什么叫“走不完”？\n因为剩下的部分数量 $\u0026lt; m $ 无法进行置换操作。故称“走不完”。\n此处要注意的是，有些人一开始会认为：“这些牌做不了置换，那就没有发生过位置变动，直接一个一个按原顺序压入 $ans[]$ 好了。”\n错误的。\n因为有一些部分“经历过”置换，可能是被换过来的。所以上面的说法并不正确。\n那这一部分怎么处理呢？\n先假设从入口 $0$ 到 $m$ 的链（路径）长度为 $l$。\n因为这是最后的 $m-1$ 个数，所以链（路径）中留下来的就是最后进入链（路径）的 $l-1$ 个数。因为没有第 $m$ 个数了（数量都 $\u0026lt; m$ 了嘛），意味着没有新的数加入进来。其余位置也就是环了（这里解释过，在 Part 2 末），那么可以用同余的方式得出每个位置上的数。\nPart 4 查询操作\r那现在，我们把置换分成的这 3 个部分全分析清楚了，那么出牌顺序就可以存下来 $ans[]$ 。询问的时候，$O(1)$ 输出就好了。\n时间复杂度： $O(n)$。\n预计： 100pts\n代码实现\r虽然时间复杂度降下来了，但是这个方法的思考难度、实现难度都比倍增法更难一些。\n所以这里贴一份全代码，各位奆奆洁身自好、不要 COPY。\n此处贴一份原题检测时AC的代码，因为是原题检测，为了手速就丢掉快读、快写了。79ms的评测代码是加了快读、快写的。\n评测下来是 90ms，这仍比 $O(n\\log n)$ 的倍增做法快了不止一点。\n[warning]： 码风丑的话喷轻一点（逃\ncode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN=1e5+5; int n,m,q; int p[MAXN],f[MAXN]; int tot,cnt,len=-1; int rk[MAXN]; int col[MAXN],ans[MAXN],b[MAXN],c[MAXN]; bool vis[MAXN]; struct node { vector\u0026lt;int\u0026gt; v; }a[MAXN]; void dfs(int x,int co) { if(col[x]) return; if(co==1) b[++len]=x; col[x]=co; rk[x]=a[co].v.size(); a[co].v.pb(x); if(x\u0026gt;=m) return; dfs(f[x+1],co); } void work1(int x) { if(col[x]==1) { if(rk[x]\u0026gt;=n-m+1) c[a[1].v[rk[x]-n+m-1]]=x; } else { int co=col[x]; int l=a[co].v.size(); c[a[co].v[((rk[x]-n+m-1)%l+l)%l]]=x; } } void work2(int x,int y) { if(vis[x]) return; if(rk[m]\u0026gt;=y) c[a[1].v[rk[m]-y]]=x; } signed main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;q); for(int i=1;i\u0026lt;=m;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;p[i]),f[p[i]]=i; for(int i=0;i\u0026lt;=m;i++) if(!col[i]) dfs(i,++tot); if(len\u0026lt;n-m+1) { for(int i=1;i\u0026lt;=len;i++) ans[++cnt]=b[i]; for(int i=1;i\u0026lt;=n-m+1-len;i++) ans[++cnt]=m+i,vis[m+i]=1; } else for(int i=1;i\u0026lt;=n-m+1;i++) ans[++cnt]=b[i]; for(int i=1;i\u0026lt;=m;i++) work1(i); for(int i=m+1,j=n-m;i\u0026lt;=n;i++,j--) work2(i,j); for(int i=1;i\u0026lt;m;i++) ans[++cnt]=c[i]; while(q--) { int x; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;x); printf(\u0026#34;%lld\\n\u0026#34;,ans[n-x+1]); } return 0; } ","date":"2023-07-29T11:42:00+08:00","permalink":"https://werchange.github.io/p/usaco13dec-the-bessie-shuffle-s-%E6%B4%97%E7%89%8C-%E9%A2%98%E8%A7%A3/","title":"[USACO13DEC] The Bessie Shuffle S 洗牌 题解"},{"content":"07.12\u0026amp;07.14模拟赛总结\r前言：\n这是最戏剧性的一集，两场都是同级第一，只不过一场正数、一场倒数。\n07.12——Day 1\rT1\rP8093 [USACO22JAN] Searching for Soulmates S\n正解\r以下除以 $2$ 操作、加 $1$ 操作、乘以 $2$ 操作分别为操作 1、2、3。\n思考发现，如果我们先前一直进行操作 1 和操作 2，那等到我们再进行操作 3 时，就不会再进行操作 1，（因为不会更优）。\n换句话说，我们操作的步骤大约分为两个部分：\n前半段：进行操作 1、2 后半段：进行操作 2、3 容易想到处理出前后半段中间的一个中间值 $t$。\n由于后半段的操作不是乘以 $2$ 就是加 $1$，所以这个 $t$ 一定是 $b$ 的前缀（二进制中）。\n那就很清晰了，直接枚举 $t$，在记录步数即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int d(int x) { for (int i = 63; i \u0026gt;= 0; --i) if (x \u0026gt;\u0026gt; i) return i + 1; return 0; } int get(int num, int x, int len) { return num \u0026gt;\u0026gt; (len - x); } void solve() { int a, b; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b); if (a == b) { puts(\u0026#34;0\u0026#34;); return; } int len = d(b); int ans = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= len; i++) { int cnt = 0; int t = get(b, i, len); int ta = a; while (ta != t) { if (ta \u0026gt; t) { if (ta \u0026amp; 1) ++ta; else ta /= 2; ++cnt; } else { cnt += t - ta; ta = t; } } for (int j = i + 1; j \u0026lt;= len; j++) { t = get(b, j, len); ta \u0026lt;\u0026lt;= 1; ++cnt; if (t != ta) ++ta, ++cnt; } ans = min(ans, cnt); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } signed main() { int n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while (n--) solve(); return 0; } T2\rP8094 [USACO22JAN] Cow Frisbee S\n正解\r直接枚举、用栈维护即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 3e5 + 5; int n, ans; int h[MAXN], x[MAXN]; stack\u0026lt;int\u0026gt; s; signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;h[i]), x[h[i]] = i; for (int i = 1; i \u0026lt;= n; i++) { while (!s.empty()) { int t = s.top(); ans += abs(x[h[i]] - x[t]) + 1; if (h[i] \u0026lt;= t) break; s.pop(); } s.push(h[i]); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } T3\rP8095 [USACO22JAN] Cereal 2 S 正解\r对于这道题，一眼二分图最大匹配，直接匈牙利带走。\n结果发现 $\\Omicron(nm)$ 把匈牙利带走。\n但是没有关系！直接建超级源点和超级汇点，dinic 网络流直接 $\\Omicron(\\sqrt{n}m)$ 带走。\n但是，这样非常难打，而且在输出排队顺序是也异常繁琐，可以说是拿考场时间换代码运行时间了……\n怎么办呢？还好这场比赛这道题最难，所以应该没有人会 A，打点部分分也是不错的选择【大拇指d(￣▽￣)b】。\n实际上这道题数据很水，匈牙利+卡常+优秀的代码逻辑是可以 A 的。\n至于输出方案，这个想想就出来了，这里不做过多赘述。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN = 2e6 + 5; int n, m; int a[MAXN]; int f[MAXN], s[MAXN]; int lk[MAXN], ilk[MAXN]; bool vis[MAXN]; vector\u0026lt;int\u0026gt; v[MAXN], vec[MAXN]; bool dfs(int x) { for (auto i : v[x]) { if (!vis[i]) { vis[i] = 1; if (!lk[i] || dfs(lk[i])) { lk[i] = x, ilk[x] = i; vis[i] = 0; return 1; } } } return 0; } int MXMC() { int re = 0; for (int i = 1; i \u0026lt;= n; i++) re += dfs(i); return re; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;f[i], \u0026amp;s[i]); v[i].pb(f[i]), v[i].pb(s[i]); vec[f[i]].pb(i); } int ans = MXMC(); printf(\u0026#34;%lld\\n\u0026#34;, n - ans); queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { if (ilk[i] != f[i]) continue; printf(\u0026#34;%lld\\n\u0026#34;, i); for (auto j : vec[f[i]]) { if (ilk[j] == s[j]) q.push(j); } } while (!q.empty()) { int u = q.front(); q.pop(); printf(\u0026#34;%lld\\n\u0026#34;, u); for (int j : vec[s[u]]) { if (ilk[j] == s[j]) q.push(j); } } for (int i = 1; i \u0026lt;= n; i++) if (!ilk[i]) printf(\u0026#34;%lld\\n\u0026#34;, i); return 0; } 总结\r$8+27+7=42/rk12$ 同级倒一、直接趋势。\n总结发现是答题时心态没有调整好，导致陷入思维怪圈，进一步导致简单题做不对、难题不会做的情况。\n07.13——Day 2\r原题检测，没打比赛。\n一早上复习，复习了上一周打过的模拟赛。幸好我都写了总结、方便复习。\n结果：\n我：（开始啦开始啦！）咦？这个“旅行商简化版”是个什么东西？\n隔壁的新初一：好像是我们作业里的一道题。\n隔壁同级：教练，这个我们要做吗？\n教练：新初三的也要做，注意一下啊。\n新初三的我们：……\n顺提，我们原题检测里的题，一题没A跑2圈……\n但成绩挺可观的：\n$100+100+52+100+71+0=423/rk2$\n好吧，跑6圈。遗憾的是期望得到 $500$ 分，可惜有两题打挂了……\n07.14——Day 3\rT1\rP9186 [USACO23OPEN] Milk Sum S\n正解\r容易想到肯定先排序嘛，那么就会得到新数组。\n发现用二分找到查询数据在新数组位置时，答案的增加与减少可以用一个后缀和来搞定。（当然，前缀和应该没问题，可是赛时我先想到了后缀和）。\n那就很容易做了，二分可以写 lower_bound，减少码量。因为近期用 set 用得比较多，所以我就干脆丢进了 set 里进行 lower_bound 操作。\n代码\r好不容易第一次赛时切绿，这里放一下我的赛时代码（无格式化、码风为本人码风）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN=2e5+5,INF=1e9; int n,ans; struct node { int x,id; bool operator\u0026lt;(const node \u0026amp;T)const { if(x!=T.x) return x\u0026lt;T.x; return id\u0026lt;T.id; } }a[MAXN],b[MAXN]; int sum[MAXN]; multiset\u0026lt;node\u0026gt; s; signed main() { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i].x); b[i].x=a[i].x; b[i].id=i; } sort(a+1,a+n+1); for(int i=n;i\u0026gt;=1;i--) { ans+=a[i].x*i; sum[i]=sum[i+1]+a[i].x; a[i].id=i; s.insert(a[i]); } s.insert({-1,0}),s.insert({INF,0}); int tmp=ans,Q; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;Q); while(Q--) { ans=tmp; int x,y; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;y); auto it=s.lower_bound({b[x].x,0}); node t=*it; ans-=t.x*t.id; auto it2=s.upper_bound({y,0}); node t2=*it2; if(t2.x==INF) { ans-=sum[t.id+1]; ans+=y*n; printf(\u0026#34;%lld\\n\u0026#34;,ans); continue; } if(t2.id==t.id) { ans+=y*t.id; printf(\u0026#34;%lld\\n\u0026#34;,ans); continue; } if(t2.id\u0026lt;t.id) { ans+=sum[t2.id]-sum[t.id]; ans+=y*t2.id; } else { ans+=y*(t2.id-1); ans-=sum[t.id+1]-sum[t2.id]; } printf(\u0026#34;%lld\\n\u0026#34;,ans); } return 0; } T2\rP9187 [USACO23OPEN] Field Day S\n正解\r这个一看就是可以转成二进制，比较就是异或操作了。\n这是个很好的思路，如果赛时没想到的话那就是能力问题了。\n因为他要求找最大不同，那脑海中可以有这样的思路： $$\r最大不同\\to 最小相同\\to 可以对其一取反\\to 最小不同\r$$ 那就很容易了，我们可以用一个非常简单的dp实现：\n设 $f_i$ 为得到 $i$ 的最小不同，最后输出答案时就是 $$\rc-f_{(2^c-1) \\oplus a_i}\r$$ 怎么转移呢？预处理一下就好了\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 1e6 + 5; int n, c; int a[MAXN]; int f[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;c, \u0026amp;n); memset(f, 0x3f, sizeof(f)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= c; j++) { char ch; cin \u0026gt;\u0026gt; ch; a[i] \u0026lt;\u0026lt;= 1; a[i] += (ch == \u0026#39;G\u0026#39;); } f[a[i]] = 0; } for (int j = 1; j \u0026lt;= c; j++) { for (int i = 1; i \u0026lt;= (1 \u0026lt;\u0026lt; c) - 1; i++) f[(1 \u0026lt;\u0026lt; (j - 1)) ^ i] = min(f[(1 \u0026lt;\u0026lt; (j - 1)) ^ i], f[i] + 1); } for (int i = 1; i \u0026lt;= n; i++) { int ans = c - f[((1 \u0026lt;\u0026lt; c) - 1) ^ a[i]]; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } T3\rP9188 [USACO23OPEN] Pareidolia S\n正解\r考虑DP。\n设 $f_i$ 为这样一个 $[1,i]$ 的区间出现 bessie 的个数。\n怎么转移呢？可以利用一下辅助数组 $lst_i$，其中 $i\\in [1,6]$。\n这是什么？\n如果出现了一个序列 bessie，那第 $i$ 位前面的 bessie 的起始位（b 的位置）\n例如 bessie，那么 $lst_i=1 ; (1\\leq i\\leq 6)$\n那么考虑转移 $f$：\n提供贡献的只有：\n前面的转移过来 当前贡献了多少 1 情况怎么处理呢？显然是 $f_{lst_6-1}$\n2 情况呢？因为当前 bessie 的出现，所以对于 $[l,lst_6] ; (l\\in [1,lst_6])$ 这些区间，答案都会 +1，所以转移量就是 $lst_6$\n综上， $$\rf_i=f_{lst_6-1}+lst_6\r$$ 因为答案是所有区间，所以答案就为: $$\r\\sum_{i=1}^n f_i\r$$ 代码\r有些许改动：\n（$dp_i \\to f_i$）\n（$f_i \\to lst_i$）\n括号里左边为代码变量，右边为思路变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; #define int long long const int MAXN = 3e5 + 5; char s[MAXN]; int f[10],dp[MAXN]; signed main() { scanf(\u0026#34;%s\u0026#34;,s+1); int n=strlen(s+1); // bessie for(int i=1;i\u0026lt;=n;i++) { if(s[i]==\u0026#39;b\u0026#39;) f[1]=i; if(s[i]==\u0026#39;e\u0026#39;) f[6]=f[5],f[2]=f[1]; if(s[i]==\u0026#39;s\u0026#39;) f[4]=f[3],f[3]=f[2]; if(s[i]==\u0026#39;i\u0026#39;) f[5]=f[4]; dp[i]=dp[f[6]-1]+f[6]; } int ans=0; for(int i=1;i\u0026lt;=n;i++) ans+=dp[i]; printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } 总结\r$100+25+17=142/rk1$\n这次 $rk1$ 不只是同级，还是同机房。\n再接再厉。\n","date":"2023-07-19T20:04:00+08:00","permalink":"https://werchange.github.io/p/07.1207.14%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"07.12\u002607.14模拟赛总结"},{"content":"07.06\u0026amp;07.11模拟赛总结\r前言：\n之前学了些新东西，所以只比了两场模拟赛，一场 Atcoder，一场 USACO。\n改完题了，趁有空总结一下。\n07.06——Day 1\rT1\r[ABC218D] Rectangles 正解\r对于每个点，都令他是矩形中左下角的点。我们可以用数组把这个点同横坐标的点都存下来，纵坐标同理。那么再判断右上角那个点是否存在即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; #define pii pair\u0026lt;int, int\u0026gt; #define ft first #define sd second #define pb push_back const int MAXN = 2e3 + 5; int n; pii a[MAXN]; map\u0026lt;int, map\u0026lt;int, bool\u0026gt;\u0026gt; vis; int cnt; vector\u0026lt;int\u0026gt; fx[MAXN]; vector\u0026lt;int\u0026gt; fy[MAXN]; bool cmp(pii aa, pii bb) { if (aa.ft != bb.ft) return aa.ft \u0026lt; bb.ft; return aa.sd \u0026lt; bb.sd; } signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); a[i] = { x, y }; vis[x][y] = 1; } sort(a + 1, a + n + 1, cmp); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = i + 1; j \u0026lt;= n; ++j) { if (a[i].ft == a[j].ft) fx[i].pb(j); if (a[i].sd == a[j].sd) fy[i].pb(j); } } for (int i = 1; i \u0026lt;= n; ++i) { for (auto i1 : fx[i]) { for (auto i2 : fy[i]) { if (vis[a[i2].ft][a[i1].sd]) ++cnt; } } } printf(\u0026#34;%d\\n\u0026#34;, cnt); return 0; } T2\r[ABC218E] Destruction 正解\r直接 kruskal 带走。对于负权边我们也不需要，所以也计算一下花费。\n考场忘记 kruskal 怎么打了，直接趋势\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define int long long const int MAXN = 2e5 + 5, INF = 0x3f3f3f3f; int n, m, tot, ans; struct edge { int u, v, w; bool operator\u0026lt;(const edge \u0026amp;t) const { return w \u0026lt; t.w; } } e[MAXN]; int fa[MAXN]; int tp[MAXN], hea; bool vis[MAXN \u0026lt;\u0026lt; 1]; inline int rd() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + (ch ^ 48), ch = getchar(); return x * f; } void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;), write(-x); return; } if (x \u0026gt; 9) write(x / 10), putchar(x % 10 + 48); else putchar(x + 48); } inline int max(int a, int b) { return a \u0026gt; b ? a : b; } int gfa(int x) { return x == fa[x] ? x : gfa(fa[x]); } int kru() { int val = 0; for (int i = 1; i \u0026lt;= m; ++i) { int rx = gfa(e[i].u), ry = gfa(e[i].v); if (e[i].w \u0026lt; 0) { val += e[i].w; if (rx \u0026lt; ry) fa[ry] = rx; else fa[rx] = ry; } else if (rx == ry) continue; else { if (rx \u0026lt; ry) fa[ry] = rx; else fa[rx] = ry; val += e[i].w; } } return val; } signed main() { n = rd(), m = rd(); for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; for (int i = 1; i \u0026lt;= m; ++i) { int u = rd(), v = rd(), w = rd(); e[i] = { u, v, w }; tot += w; } sort(e + 1, e + m + 1); ans = tot - kru(); write(max(ans, 0ll)); putchar(\u0026#39;\\n\u0026#39;); return 0; } T3\r[ABC218F] Blocked Roads 正解\r可以跑一遍堆优化 Dijkstra，然后找出最短路径（主干路径），对于删掉的边，判断是否为主干路径。如果不是，那对最优答案无影响；否则再跑一遍。\n时间复杂度可以证明。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #define int long long const int MAXN = 400 + 5, MAXM = 2e5 + 5, INF = 0x3f3f3f3f3f3f3f3f; int n, m; int su, en[MAXM], lt[MAXM], hd[MAXN]; int dis[MAXN]; bool viz[MAXM], vis[MAXN]; int nxt[MAXN][2]; bool isok[MAXM]; struct node { int ix, vl; bool operator\u0026gt;(const node \u0026amp;t) const { if (vl != t.vl) return vl \u0026gt; t.vl; return ix \u0026lt; t.ix; } }; inline int rd() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + (ch ^ 48), ch = getchar(); return x * f; } void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;), write(-x); return; } if (x \u0026gt; 9) write(x / 10), putchar(x % 10 + 48); else putchar(x + 48); } inline void add(int u, int v) { en[++su] = v, lt[su] = hd[u], hd[u] = su; } inline int Dij(int x) { priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= m; ++i) viz[i] = (i == x) ? 1 : 0; for (int i = 1; i \u0026lt;= n; ++i) vis[i] = 0, dis[i] = INF; q.push({ 1, 0 }); vis[1] = 1; dis[1] = 0; while (!q.empty()) { int u = q.top().ix; q.pop(); for (int i = hd[u]; i; i = lt[i]) { if (viz[i]) continue; int v = en[i]; if (dis[v] \u0026gt; dis[u] + 1) { nxt[v][0] = u, nxt[v][1] = i; dis[v] = dis[u] + 1; if (!vis[v]) vis[v] = 1, q.push({ v, dis[v] }); } } } return dis[n]; } signed main() { n = rd(), m = rd(); for (int i = 1; i \u0026lt;= m; ++i) { int u = rd(), v = rd(); add(u, v); } int Max = Dij(0); Max = (Max == INF) ? -1 : Max; int tmp = n; while (tmp != 0) { isok[nxt[tmp][1]] = 1; tmp = nxt[tmp][0]; } for (int x = 1, ans; x \u0026lt;= m; ++x) { if (isok[x]) { ans = Dij(x); if (ans == INF) ans = -1; } else ans = Max; write(ans), putchar(\u0026#39;\\n\u0026#39;); } return 0; } T4\r[ABC218G] Game on Tree 2\n正解\r你以为是博弈论，然后开始推 SG，其实并没有什么 SG 函数。\n因为两人的目标不同，所以对待选择儿子节点时，一个人要最大、另一个人要最小。可以考虑 DP。 仔细想想，发现两人是回合制的，所以对待不同的人操作，有不同的转移方程。\n选最大的人： $$\rf_i=max\\{ f_j \\}\r$$ 选最小的人： $$\rf_i=min\\{f_j\\}\r$$ 其中 $j$ 为 $i$ 的儿子节点。\n如何维护中位数呢？方法很多，上至平衡树、下至对顶堆，甚至平板电视。这里给出两个 multiset 维护的办法。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define pb push_back const int MAXN = 2e5 + 5, INF = 0x3f3f3f3f; int n; int a[MAXN], f[MAXN]; vector\u0026lt;int\u0026gt; G[MAXN]; struct node { multiset\u0026lt;int\u0026gt; s, t; void update() { if (s.size()) { auto it = s.end(); --it; t.insert(*it), s.erase(it); } while (s.size() \u0026lt; t.size()) { auto it = t.begin(); s.insert(*it), t.erase(it); } } void ins(int x) { s.insert(x); update(); } void era(int x) { auto it = s.end(); --it; if (x \u0026lt;= *it) s.erase(s.lower_bound(x)); else t.erase(t.lower_bound(x)); update(); } int query() { auto it = s.end(); --it; if (s.size() \u0026gt; t.size()) return *it; return ((*it) + (*t.begin())) / 2; } } S; void dfs(int x, int fa, int dep) { S.ins(a[x]); bool isok = 0; int minz = INF, maxz = 0; for (auto y : G[x]) { if (y == fa) continue; isok = 1; dfs(y, x, dep + 1); minz = min(minz, f[y]); maxz = max(maxz, f[y]); } if (!isok) f[x] = S.query(); else { if (dep \u0026amp; 1) f[x] = maxz; else f[x] = minz; } S.era(a[x]); } signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt; n; ++i) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].pb(v), G[v].pb(u); } dfs(1, 1, 1); printf(\u0026#34;%d\\n\u0026#34;, f[1]); return 0; } 总结\r174pts/rk11（同级倒数第二）\n怎么说呢，本来应该 300pts 是没问题的。可是 T2 被 kruskal 卡住了，一直在回忆。以至于没有深入思考T3。\n这告诉我们，学过的算法知识一定要复习！！\n07.11——Day 2\rT1\rP7990 [USACO21DEC] Closest Cow Wins S\n正解\r有感：其实这道题是最难的（蓝）。结果考场死磕这道题，以至于T3（黄）都没仔细想。\n解法1\r因为有 $m$ 个敌对奶牛，所以道路被分成了 $m+1$ 个部分。因为我们放奶牛可以放在小数位上而敌对奶牛不行、且敌对奶牛不和草场重合。\n所以对于每个部分，我们都只需要两只奶牛就可以将这个部分所有草场的美味度“包揽”。\n那如果只是一只奶牛呢？\n显然，有一些草场就无法“包揽”。如果我们在这个范围 $(f_{i-1},f_i)$ 内随便找一个点 $q$ 来放置奶牛，那这只奶牛可以“包揽”的草场只有 $(\\frac{f_{i-1}+q}{2},\\frac{q+f_i}{2})$ 范围内的草场。\n但是我们发现，如果我们进行一下 $r-l$ 的操作，可得 $\\frac{f_i-f_{i-1}}{2}$。所以这个范围的长度与奶牛放置点无关。\n可以想到什么？一个区间且长度没有变换……\n滑动窗口！！\n正确的。但是我写了解法2，并且考场也想到了解法 2，只是打挂了。\n解法2\r对于每个草场，左边或右边肯定有一个敌对奶牛，那么我们以草场为圆心求出一个最大半径，使得这个范围内没有敌对奶牛。\n那就很容易了，可以得到类似于一条条的线段。将有重合部分的变为同一块“草场”。然后排下序就可以输出了。\n代码\r此处为解法 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN = 2e5 + 5; int n, m, k; struct node { int p, t; bool operator\u0026lt;(const node \u0026amp;A) const { return p \u0026lt; A.p; } } a[MAXN]; int f[MAXN]; int d[MAXN]; vector\u0026lt;node\u0026gt; ans; bool cmp(node a, node b) { if (a.t != b.t) return a.t \u0026gt; b.t; return a.p \u0026lt; b.p; } signed main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;k, \u0026amp;m, \u0026amp;n); for (int i = 1; i \u0026lt;= k; i++) { int p, t; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;p, \u0026amp;t); a[i] = { p, t }; } for (int i = 1; i \u0026lt;= m; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;f[i]); sort(f + 1, f + m + 1); sort(a + 1, a + k + 1); memset(d, 0x3f, sizeof(d)); for (int i = 1; i \u0026lt;= k; i++) { int it = lower_bound(f + 1, f + m + 1, a[i].p) - f; if (it != m + 1) d[i] = min(d[i], f[it] - a[i].p); if (it != 1) d[i] = min(d[i], a[i].p - f[it - 1]); } ans.pb({ a[1].p + d[1] - 1, a[1].t }); for (int i = 2; i \u0026lt;= k; i++) { if (a[i].p - d[i] \u0026lt; ans.back().p) { node tmp = ans.back(); ans.pop_back(); ans.pb({ tmp.p, tmp.t + a[i].t }); } else ans.pb({ a[i].p + d[i] - 1, a[i].t }); } sort(ans.begin(), ans.end(), cmp); int cnt = 0; for (int i = 0; i \u0026lt; n; i++) cnt += ans[i].t; printf(\u0026#34;%lld\\n\u0026#34;, cnt); return 0; } T2\r题目描述\rFarmer John 的农场由 $N$ 块田地（$1 \\leq N \\leq 10^5$）组成，编号为 $1 \\ldots N$。在这些田地之间有 $M$ 条双向道路（$0 \\leq M \\leq 10^5$），每条道路连接两块田地。\n农场有两个牛棚，一个在田地 1 中，另一个在田地 $N$ 中。Farmer John 希望确保有一种方式可以沿着一组道路在两个牛棚之间行走。 他愿意建造至多两条新道路来实现这一目标。由于田地的位置因素，在田地 $i$ 和 $j$ 之间建造新道路的花费是 $(i-j)^2$。\n请帮助 Farmer John 求出使得牛棚 $1$ 和 $N$ 可以相互到达所需要的最小花费。\n输入格式\r每个测试用例的输入包含 $T$ 个子测试用例（$1\\le T\\le 20$），所有子测试用例必须全部回答正确才能通过整个测试用例。\n输入的第一行包含 $T$，之后是 $T$ 个子测试用例。\n每个子测试用例的第一行包含两个整数 $N$ 和 $M$。以下 $M$ 行，每行包含两个整数 $i$ 和 $j$，表示一条连接两个不同田地 $i$ 和 $j$ 的道路。输入保证任何两个田地之间至多只有一条道路，并且所有子测试用例的 $N+M$ 之和不超过 $5 \\cdot 10^5$。\n输出格式\r输出 $T$ 行。第 $i$ 行包含一个整数，为第 $i$ 个子测试用例的最小花费。\n样例输入 #1\r1 2 3 4 5 6 7 8 2 5 2 1 2 4 5 5 3 1 2 2 3 4 5 样例输出 #1\r1 2 2 1 正解\r因为只会最多建 $2$ 条边，所以我们有两种方法：\n直接连接 $1$ 所在连通块与 $n$ 所在连通块，只需连 $1$ 条边 通过一个“媒介”连通块来使得 $1$ 与 $n$ 连通，需要连 $2$ 条边 那通过并查集可以搞定连通块，通过 set 的二分找出边权尽可能小的。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define int long long #define po(x) ((x) * (x)) const int MAXN = 5e5 + 5, INF = 1e14; int T, n, m; int fa[MAXN]; set\u0026lt;int\u0026gt; s1, s2; int a[MAXN], b[MAXN]; int gf(int x) { return x == fa[x] ? x : gf(fa[x]); } void un(int u, int v) { int rx = gf(u), ry = gf(v); if (rx \u0026gt; ry) fa[rx] = ry; else fa[ry] = rx; } bool cmp(int x, int y) { int rx = gf(x), ry = gf(y); if (rx != ry) return rx \u0026lt; ry; return x \u0026lt; y; } void solve() { int ans = INF; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) fa[i] = i; for (int i = 1; i \u0026lt;= m; i++) { int u, v; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;u, \u0026amp;v); un(u, v); } int r1 = gf(1), rn = gf(n); if (r1 == rn) { puts(\u0026#34;0\u0026#34;); return; } s1.clear(), s2.clear(); int tmp = 0, cnt = 0; s1.insert(0), s1.insert(n + 1); s2.insert(0), s2.insert(n + 1); for (int i = 1; i \u0026lt;= n; i++) { int rt = gf(i); if (rt == r1) s1.insert(i); else if (rt == rn) b[++cnt] = i, s2.insert(i); else a[++tmp] = i; } for (int i = 1; i \u0026lt;= cnt; i++) { int v = b[i]; auto it1 = s1.lower_bound(v); --it1; auto it2 = s1.upper_bound(v); int t1 = (*it1), t2 = (*it2); if (t1 != 0) ans = min(ans, po(v - t1)); if (t2 != n + 1) ans = min(ans, po(v - t2)); } sort(a + 1, a + tmp + 1, cmp); int min1 = INF, min2 = INF; for (int i = 1; i \u0026lt;= tmp; i++) { if (i \u0026gt; 1 \u0026amp;\u0026amp; gf(a[i]) != gf(a[i - 1])) { ans = min(ans, min1 + min2); min1 = min2 = INF; } auto it1 = s1.lower_bound(a[i]); --it1; auto it2 = s1.upper_bound(a[i]); int t1 = (*it1), t2 = (*it2); if (t1 != 0) min1 = min(min1, po(a[i] - t1)); if (t2 != n + 1) min1 = min(min1, po(a[i] - t2)); it1 = s2.lower_bound(a[i]); --it1; it2 = s2.upper_bound(a[i]); t1 = (*it1), t2 = (*it2); if (t1 != 0) min2 = min(min2, po(a[i] - t1)); if (t2 != n + 1) min2 = min(min2, po(a[i] - t2)); } ans = min(ans, min1 + min2); printf(\u0026#34;%lld\\n\u0026#34;, ans); } signed main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;T); while (T--) solve(); return 0; } T3\rP7992 [USACO21DEC] Convoluted Intervals S\n正解\r用到了差分。\n发现 $m$ 老小了，那就思考从这方面做文章。\n我们发现，这个一组 $i$ 与一组 $j$ 可以给出贡献为 $a_i\\times a_j$，$a[i]$为桶，统计起点 $i$ 出现了几遍。\n如果你打过 25pts 部分分的暴力的话，你就明白为什么要用差分。这里不展开了。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int MAXN = 2e5 + 5; int n, m; int a[MAXN], b[MAXN]; int f[MAXN \u0026lt;\u0026lt; 1]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int x, y; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y); a[x]++, b[y]++; } for (int i = 0; i \u0026lt;= m; i++) { for (int j = 0; j \u0026lt;= m; j++) { f[i + j] += a[i] * a[j]; f[i + j + 1] -= b[i] * b[j]; } } for (int i = 0, ans = 0; i \u0026lt;= m + m; i++) { ans += f[i]; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 总结\r124pts/rk6\n还不错，可是还不是我能到达的最大高度，这可能是个良好开端。\n总总结\r用日日新的态度来学竞赛，收获真的很大！\n借这次良好开端，下次“扶摇直上九万里”！\n怎么说AKCSP-J、CSP-S拿个一等吧\n","date":"2023-07-11T21:36:00+08:00","permalink":"https://werchange.github.io/p/07.0607.11%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"07.06\u002607.11模拟赛总结"},{"content":"2023.7月初模拟赛总结\r前言：\n近期（约）3天比了3场模拟赛，都源于USACO。但是这3场我的成绩都很低，赛后一看题解被自己的智商哭死，实在看不下去了，决定要写一篇总结\nDay 1\rT1\rP3132 [USACO16JAN] Angry Cows G 正解\rDP，设 $f_i$ 为使第 $i$ 个干草堆左边的所有干草堆爆炸的最小力度。\n考虑转移方程。\n找一个 $j$，满足：\n$j\u0026lt;i$ $a_i-a_j\u0026gt;f_j+1$ 会有很多个 $j$，我们需要最后一个，即最靠近 $i$ 的那一个。\n易得： $$\rf_i=min(a_i-a_j,f_{j+1}+1)\r$$ 其中 $f_1=0$\n类似的，我们可得使右边的爆炸的 $g[]$ 的状态转移方程。\n最后我们枚举爆炸点，显然： $$\rans=min\\{max(\\frac{a_j-a_i}{2},max(f_i,g_j)+1) \\}\r$$ 其中，$i$ 和 $j$ 的互相推进用到了贪心策略。\n还有一点，因为最优情况爆炸点只可能在整点或两个整点中间，所以为了避免double精度问题，我们可以都乘以一个 $2$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 5e4 + 5, INF = 0x3f3f3f3f; ll n; ll f[MAXN], g[MAXN]; ll a[MAXN]; int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); rp(i, 1, n) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]), a[i] *= 2; sort(a + 1, a + n + 1); memset(f, 0x3f, sizeof(f)); memset(g, 0x3f, sizeof(g)); ll t = 1; f[1] = 0; rp(i, 2, n) { while (t + 1 \u0026lt; i \u0026amp;\u0026amp; a[i] - a[t + 1] \u0026gt; f[t + 1] + 2) ++t; f[i] = min(a[i] - a[t], f[t + 1] + 2); } t = n; g[n] = 0; pr(i, n - 1, 1) { while (t - 1 \u0026gt; i \u0026amp;\u0026amp; a[t - 1] - a[i] \u0026gt; g[t - 1] + 2) --t; g[i] = min(a[t] - a[i], g[t - 1] + 2); } ll ans = INF; for (ll i = 1, j = n; i \u0026lt; j;) { ans = min(ans, max((a[j] - a[i]) / 2, max(f[i], g[j]) + 2)); if (f[i + 1] \u0026lt; g[j - 1]) ++i; else --j; } printf(\u0026#34;%.1lf\u0026#34;, (double)ans / 2); return 0; } T2\rP3133 [USACO16JAN] Radio Contact G 正解\rdp,设 $f_{i,j}$ 为在 $(i,j)$ 时最小代价。对于他们的行动串，分别用两个递推数组储存他们的横坐标与纵坐标。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define po(x) ((x) * (x)) const ll MAXN = 1e3 + 5; ll n, m; ll fx, fy, cx, cy; ll f[MAXN][MAXN]; ll ax[MAXN], bx[MAXN], ay[MAXN], by[MAXN]; ll d(ll i, ll j) { return po(fx + ax[i] - (cx + bx[j])) + po(fy + ay[i] - (cy + by[j])); } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;fx, \u0026amp;fy, \u0026amp;cx, \u0026amp;cy); rp(i, 1, n) { char ch; cin \u0026gt;\u0026gt; ch; ax[i] = ax[i - 1], ay[i] = ay[i - 1]; if (ch == \u0026#39;N\u0026#39;) ay[i]++; if (ch == \u0026#39;S\u0026#39;) ay[i]--; if (ch == \u0026#39;W\u0026#39;) ax[i]--; if (ch == \u0026#39;E\u0026#39;) ax[i]++; } rp(i, 1, m) { char ch; cin \u0026gt;\u0026gt; ch; bx[i] = bx[i - 1], by[i] = by[i - 1]; if (ch == \u0026#39;N\u0026#39;) by[i]++; if (ch == \u0026#39;S\u0026#39;) by[i]--; if (ch == \u0026#39;W\u0026#39;) bx[i]--; if (ch == \u0026#39;E\u0026#39;) bx[i]++; } memset(f, 0x3f, sizeof(f)); f[0][0] = 0; rp(i, 0, n) { rp(j, 0, m) { if (i != 0) f[i][j] = min(f[i][j], f[i - 1][j] + d(i, j)); if (j != 0) f[i][j] = min(f[i][j], f[i][j - 1] + d(i, j)); if (i != 0 \u0026amp;\u0026amp; j != 0) f[i][j] = min(f[i][j], f[i - 1][j - 1] + d(i, j)); } } printf(\u0026#34;%lld\\n\u0026#34;, f[n][m]); return 0; } T3\rP3134 [USACO16JAN] Lights Out G\n正解\r按照题意所说，枚举每个点出发的情况。再把路径记录下来，看看这条路径是否唯一。若唯一，则“觉醒”。\n我们可以用map储存，路径可以压成 string。\n其中对于路径储存问题，我们需要知道这条边的长度与这个角的角度。由于这里的角度不是 270° 就是 90°，所以判断旋转方向即可。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 200 + 5; ll n; struct node { ll x, y; } a[MAXN]; map\u0026lt;string, ll\u0026gt; ma; ll ans; ll len[MAXN], dis[MAXN]; string ang[MAXN], ls[MAXN]; bool got(ll i, ll j, ll k) { bool op; if (a[i].x == a[j].x) { if (a[j].y \u0026gt; a[i].y) { if (a[k].x \u0026gt; a[j].x) op = 1; else op = 0; } else { if (a[k].x \u0026gt; a[j].x) op = 0; else op = 1; } } else { if (a[j].x \u0026gt; a[i].x) { if (a[k].y \u0026gt; a[j].y) op = 0; else op = 1; } else { if (a[k].y \u0026gt; a[j].y) op = 1; else op = 0; } } return op; } inline string work(ll x) { string s; ll a[10], hd = 0; while (x) { a[++hd] = x % 10; x /= 10; } pr(i, hd, 1) s += a[i] + 48; return s; } int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); rp(i, 1, n) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].y); rp(i, 1, n) { ll i0 = i - 1, i1 = i + 1; if (i0 \u0026lt; 1) i0 = n - i0; if (i1 \u0026gt; n) i1 = i1 - n; ang[i] = got(i0, i, i1) ? \u0026#34;A\u0026#34; : \u0026#34;B\u0026#34;; len[i] = abs(a[i0].x - a[i].x) + abs(a[i0].y - a[i].y); } rp(i, 1, n) { ls[i] = work(len[i]); ll t1 = len[1], t2 = len[2]; if (i == 1) continue; rp(j, i + 1, n) t1 += len[j]; pr(j, i - 1, 2) t2 += len[j + 1]; dis[i] = min(t1, t2); } rp(i, 2, n) { string s; s += ang[i]; ma[s]++; rp(j, i + 1, n) { s = s + ls[j] + ang[j]; ma[s]++; } } rp(i, 2, n) { ll now = -1; string s; s += ang[i]; if (ma[s] == 1) continue; ll sum = 0; rp(j, i + 1, n) { s = s + ls[j] + ang[j]; sum += len[j]; if (ma[s] == 1) { now = j; break; } } if (now == -1) ans = max(ans, sum + len[1] - dis[i]); else ans = max(ans, dis[now] + sum - dis[i]); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } 总结\r同年级rk12，倒数第一……\n其实题都不难，可能是脑子抽了……\nDay 2\rT1\rP8901 [USACO22DEC] Circular Barn S\n正解\r这是巴什博奕。\n上来先筛一遍质数，欧拉筛 $O(n)$ 搞定。\n经过打表找规律会发现一个房间内只要是对于 $4$ 的倍数，则先手必输。（可以证明，但这里不展开了）\n对于先手而言，肯定自己占优时希望能快则快、占劣时能拖则拖。\n所以我们记录一下轮数（两人都进行一次操作称为一轮）。\n如果是 $4$ 的倍数，两人最优策略都只能不停出 $2$，所以我们这一个房间结束时，经历了 $i/4+1$ 轮。\n如果不是，那先手可以取走一个数使得剩下的数右边为 $4$ 的倍数。记录一下 $i \\mod 4$ 最大数 $i$。\n那么怎么知道答案呢？记录先手获胜时最小轮数 $min_1$ 与这个房间号 $pos_1$，后手同理。\n然后比较 $min_1$ 与 $min_2$ 的大小，谁更小，意味着谁更快赢得游戏。\n想等的话比较谁的房间号更小。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include \u0026lt;cstdio\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 2e5 + 5, MAXM = 5e6 + 5, INF = 0x7f7f7f7f; ll T, n; ll a[MAXN], pri[MAXM], pinum; bool ispr[MAXM]; ll s[4]; ll ans[MAXM]; inline ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + (ch ^ 48), ch = getchar(); return x * f; } inline void write(ll x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;), write(-x); return; } if (x \u0026gt; 9) write(x / 10), putchar(x % 10 + 48); else putchar(x + 48); } void getprime(ll n) { ans[1] = 1; s[1] = 1; for (ll i = 2; i \u0026lt;= n; ++i) { if (!ispr[i]) { pri[++pinum] = i; if (i % 4) s[i % 4] = i; } for (ll j = 1; j \u0026lt;= pinum; ++j) { if (i * pri[j] \u0026gt; n) break; ispr[i * pri[j]] = 1; if (i % pri[j] == 0) break; } if (i % 4 == 0) ans[i] = i / 4 + 1; else ans[i] = (i - s[i % 4]) / 4 + 1; } } int main() { getprime(MAXM - 5); T = read(); while (T--) { n = read(); ll min1 = INF, pos1, min2 = INF, pos2; rp(i, 1, n) { a[i] = read(); if (a[i] % 4 == 0) { if (min2 \u0026gt; ans[a[i]]) { min2 = ans[a[i]]; pos2 = i; } } else { if (min1 \u0026gt; ans[a[i]]) { min1 = ans[a[i]]; pos1 = i; } } } if (min1 \u0026lt; min2) puts(\u0026#34;Farmer John\u0026#34;); else if (min1 \u0026gt; min2) puts(\u0026#34;Farmer Nhoj\u0026#34;); else { if (pos1 \u0026lt; pos2) puts(\u0026#34;Farmer John\u0026#34;); else puts(\u0026#34;Farmer Nhoj\u0026#34;); } } return 0; } T2\rP8903 [USACO22DEC] Bribing Friends G 正解\rdp，但是需要优化。\n$O(n^3)$ 的朴素dp这里不说了，直接说正解。\n设 $f_{i,j}$ 为遍历了前 $i$ 个人，花了 $j$ 个雪糕可以得到的最大利润。\n设 $g_{i,j}$ 为花了 $j$ 元的最大利润。\n然后我们枚举在哪一个人身上既花雪糕又花钱。\n这显然可以证明只会有一个人既花雪糕又花钱，那他前面的就都用雪糕、后面的就都用钱来支付。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) const ll MAXN = 2e3 + 5; ll n, A, B; ll f[MAXN][MAXN]; ll g[MAXN][MAXN]; struct node { ll p, c, x, xc; bool operator\u0026lt;(const node \u0026amp;t) const { return x \u0026lt; t.x; } } a[MAXN]; int main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;A, \u0026amp;B); rp(i, 1, n) { ll x, y, z; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); a[i] = { x, y, z, y * z }; } sort(a + 1, a + n + 1); rp(i, 1, n) { rp(j, 0, B) f[i][j] = f[i - 1][j]; pr(j, B, a[i].xc) f[i][j] = max(f[i][j], f[i - 1][j - a[i].xc] + a[i].p); } pr(i, n, 1) { rp(j, 0, A) g[i][j] = g[i + 1][j]; pr(j, A, a[i].c) g[i][j] = max(g[i][j], g[i + 1][j - a[i].c] + a[i].p); } ll ans = 0; rp(i, 1, n) { ans = max(ans, max(f[i - 1][B] + g[i][A], f[i][B] + g[i + 1][A])); for (ll j = 0; j \u0026lt;= min(A, a[i].c); ++j) { if (B \u0026lt; (a[i].c - j) * a[i].x) continue; ans = max(ans, f[i - 1][B - (a[i].c - j) * a[i].x] + g[i + 1][A - j] + a[i].p); } } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } T3\rP8904 [USACO22DEC] Mountains G\n正解\r暴力膜你模拟。\n我们每个山峰都建一个set，记录他右边能看到的山有哪些。\n在修改一座山 $x$ 的数据后，判断山 $x$ 会不会挡住山 $i$ 本来能看见的一些山。若挡住，则将山 $x$ 右边的山从 $s_i$ 中删掉。\n对于山 $x$ 本身，重构就好了。\n能互相看到的山的对数在这个过程中也可以统计出来。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define ins insert #define era erase #define upp upper_bound #define low lower_bound const ll MAXN = 2e3 + 5; ll n, ans; ll a[MAXN]; set\u0026lt;ll\u0026gt; s[MAXN]; double gotk(ll i, ll j) { return 1.0 * (a[j] - a[i]) / (j - i); } int main() { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); rp(i, 1, n) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); rp(i, 1, n) { s[i].ins(0), s[i].ins(n + 1); double k = -1e9; rp(j, i + 1, n) { if (gotk(i, j) \u0026gt;= k) { k = gotk(i, j); s[i].ins(j); ++ans; } } } ll Q; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;Q); while (Q--) { ll ix, h; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;ix, \u0026amp;h); a[ix] += h; rp(i, 1, ix - 1) { auto it = s[i].low(ix); it--; ll y = *it; if (y \u0026amp;\u0026amp; gotk(i, y) \u0026gt; gotk(i, ix)) continue; if (s[i].find(ix) == s[i].end()) s[i].ins(ix), ++ans; for (y = *s[i].upp(ix); y \u0026lt;= n; y = *(s[i].upp(y))) { if (gotk(i, y) \u0026gt;= gotk(i, ix)) break; s[i].era(y), --ans; } } ans -= s[ix].size() - 2; s[ix].ins(0), s[ix].ins(n + 1); double k = -1e9; rp(i, ix + 1, n) { if (gotk(ix, i) \u0026gt;= k) { k = gotk(ix, i); s[ix].ins(i); ++ans; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 总结\r同级rk5，但是大家都没打好，太难了，没有人A。\n可能是我这次比较走运。\nDay 3\r补题去了。\n顺便一提，一道绿题做了一天……\n其实还是很简单的，但是我的脑细胞却死了不少。。\n罪魁祸首：\nDay 4\rT1\rP3090 [USACO13NOV] Empty Stalls G 正解\r签到题，但是我没做出来。\n赛后看了题解，只要扫一遍就好了，注意要再扫一轮，以免一些特殊情况。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;set\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; #define int long long #define rp(i, o, p) for (int i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (int i = o; i \u0026gt;= p; --i) const int MAXN = 3e6 + 5, MAXK = 1e4 + 5; int n, k; int num[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); rp(i, 1, k) { int x, y, a, b; scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;a, \u0026amp;b); rp(j, 1, y) { int t = a * j % n + b % n; t %= n; num[t] += x; } } rp(i, 0, n - 1) { if (num[i]) { num[(i + 1) % n] += num[i] - 1; num[i] = 1; } } if (num[0]) for (int i = 0; i \u0026lt; n; ++i) { if (num[i]) { num[(i + 1) % n] += num[i] - 1; num[i] = 1; } } rp(i, 0, n - 1) if (!num[i]) { printf(\u0026#34;%lld\\n\u0026#34;, i); break; } return 0; } T2\rP3088 [USACO13NOV] Crowded Cows S 正解\r又是签到题，可是我又傻了。\n单调队列维护最大值，然后判断即可。\n注意正反都做一遍，可以做到 $O(n)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; #define int long long #define rp(i, o, p) for (int i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (int i = o; i \u0026gt;= p; --i) const int MAXN = 1e5 + 5; int n, d; struct node { int x, h; bool operator\u0026lt;(const node \u0026amp;t) const { return x \u0026lt; t.x; } } a[MAXN], q[MAXN]; bool l[MAXN], r[MAXN]; signed main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;d); rp(i, 1, n) scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].h); sort(a + 1, a + n + 1); int lf = 1, rg = 0; rp(i, 1, n) { while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[rg].h \u0026lt; a[i].h) --rg; q[++rg] = a[i]; while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[lf].x \u0026lt; a[i].x - d) ++lf; if (q[lf].h \u0026gt;= a[i].h * 2) l[i] = 1; } memset(q, 0, sizeof(q)); lf = 1, rg = 0; pr(i, n, 1) { while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[rg].h \u0026lt; a[i].h) --rg; q[++rg] = a[i]; while (lf \u0026lt;= rg \u0026amp;\u0026amp; q[lf].x \u0026gt; a[i].x + d) ++lf; if (q[lf].h \u0026gt;= a[i].h * 2) r[i] = 1; } int ans = 0; rp(i, 1, n) if (l[i] \u0026amp;\u0026amp; r[i])++ ans; printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } T3\rP3089 [USACO13NOV] Pogo-Cow S\n正解\rdp，容易想到设 $f_{i,j}$ 为第 $i$ 点，从第 $j$ 点跳过来的最大分值。\n可得 $$\rf_{i,j}=f_{j,k}+p_i\r$$ 但是会爆。 若 $i\\to i-1$\n得 $$\rf_{i-1,j}=f_{j,k}+p_{i-1}\r$$ 结合一下，得 $$\rf_{i,j}=f_{i-1,j}-p_{i-1}+p_i\r$$ 好像没 $k$ 什么事了。\n我们思考一下，如果固定 $j$ 点，$i$ 点与 $k$ 点的变换类似于共同进行，所以我们可以在同一个循环中搞定。\n时间复杂度 $O(n^2)$。\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 1e3 + 5; int n; struct node { int x, p; bool operator\u0026lt;(const node \u0026amp;t) const { return x \u0026lt; t.x; } } a[MAXN]; int ans; int f[MAXN][MAXN]; signed main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[i].x, \u0026amp;a[i].p); sort(a + 1, a + n + 1); for (int j = 1; j \u0026lt;= n; ++j) { f[j][j] = a[j].p; int k = j + 1; for (int i = j + 1; i \u0026lt;= n; ++i) { f[i][j] = f[i - 1][j] - a[i - 1].p; while (k \u0026gt; 1 \u0026amp;\u0026amp; a[j].x - a[k - 1].x \u0026lt;= a[i].x - a[j].x) f[i][j] = max(f[i][j], f[j][--k]); f[i][j] += a[i].p; ans = max(ans, f[i][j]); } ans = max(ans, f[j][j]); } for (int j = n; j \u0026gt;= 1; --j) { f[j][j] = a[j].p; int k = j - 1; for (int i = j - 1; i \u0026gt;= 1; --i) { f[i][j] = f[i + 1][j] - a[i + 1].p; while (k \u0026lt; n \u0026amp;\u0026amp; a[k + 1].x - a[j].x \u0026lt;= a[j].x - a[i].x) f[i][j] = max(f[i][j], f[j][++k]); f[i][j] += a[i].p; ans = max(f[i][j], ans); } ans = max(ans, f[j][j]); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结\r同级倒数第一，有两个人AK……\n总总结\r“开动脑筋。”这是教练常说的话。\n确实，这个暑假如果不改变不勤思考的习惯，只会被淘汰。\n","date":"2023-07-07T07:27:00+08:00","permalink":"https://werchange.github.io/p/2023.7%E6%9C%88%E5%88%9D%E6%A8%A1%E6%8B%9F%E8%B5%9B%E6%80%BB%E7%BB%93/","title":"2023.7月初模拟赛总结"},{"content":"二分图最大匹配\r前言：其实老早就学了，但是之前学的时候不透彻，稀里糊涂背背模板就过去了。果然，在最近一次原题检测上找到了我，然后就“暴毙”了。\n我就意识到学算法不能这么学，要摸清楚规律、掌握证明方法、思考推论过程。\n俗话说“温故而知新”，的确，我也在复习的过程中有了更透彻的理解。所以我决定写一篇笔记。\n本文有很多地方直接搬用了一些参考资料，所以本篇笔记原创部分主要为对关键部分进行解释。\n建议：草稿纸和笔永远是最好的工具。在看本文过程中，要仔细思考任何一部分，不要囫囵吞枣。\n注：本篇文章是我这个小蒟蒻写的，真正的dalao请看个玩笑便好，不必争论对错（但是欢迎指出文章存在的小错误）。\n二分图初步\r建议：如果你已对此有些许了解，可以根据目录直接跳到二分图匹配部分\n什么是二分图\r参考资料是这样介绍的：\n二分图又称作二部图，是图论中的一种特殊模型。 设 $G=(V, E)$ 是一个无向图。如果顶点集 $V$ 可分割为两个互不相交的子集 $X$ 和 $Y$，并且图中每条边连接的两个顶点一个在 $X$ 中，另一个在 $Y$ 中，则称图 $G$ 为二分图。 但其实可以简化成一张图去理解：\n上图就是一个二分图。\n二分图性质\r参考资料：\n定理：当且仅当无向图 $G$ 的每一个回路的边数均是偶数时，$G$ 才是一个二分图。如果无回路，相当于任一回路的边数为 $0$，故也视为二分图。 二分图判定\r参考资料这里写得太复杂了，简单的话描述一下：\n如果是一个连通图 从顶点 $1$ 开始宽度遍历整个图（$BFS$） 对遍历到的点进行染色，只染黑、白两色 染色过程中做到相邻点的颜色不同 如果不是一个连通图 在每个连通块中作判定，判定方法与上面相似 如下图，可判定为一个二分图：\n为了观察方便，这里用红、蓝两色代替了黑、白两色。\n二分图匹配\r什么是匹配\r先看看参考资料怎么说：\n给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 ${E}$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。\n图中加粗的边是数量为 $2$ 的匹配。\n这里讲得很清楚，不过多赘述（下文当资料讲得很简单明了时，也不会再过多解释）。\n什么是最大匹配\r选择边数最大的子图称为图的最大匹配问题。\n如图加粗的边是一个最大匹配：\n可以简单理解为使 $X$ 部的顶点和 $Y$ 部的顶点匹配尽可能多。\n什么是增广路径\r设 $M$ 为二分图 $G$ 已匹配边的集合，若 $P$ 是图 $G$ 中一条连通两个未匹配顶点的路径（$P$ 的起点在 $X$ 部，终点在 $Y$ 部，反之亦可），并且属 $M$ 的边和不属 $M$ 的边(即已匹配和待匹配的边)在 $P$ 上交替出现，则称 $P$ 为相对于 $M$ 的一条增广路径。\n增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有……最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行，显然 $P$ 有奇数条边。\n为什么 $P$ 会有奇数条边呢？\n根据定义，$P$ 路径的起点和终点不在同一个部，所以必然是奇数条边。\n下面来根据这个图找一下增广路：\n易得一条路径： $$\rx_4 \\rightarrow y_3 \\rightarrow x_2 \\rightarrow y_1\\rightarrow x_1\\rightarrow y_2\r$$ 因为 $y_2$ 是 $Y$ 部中未匹配的点，所以此路径是增广路径。\n其中 $\\in M$ 的边有 $(x_2,y_3),(x_1,y_1)$，不属于匹配的边有 $(x_4,y_3),(x_2,y_1),(x_1,y_2)$。\n可见不属于匹配的边要多一条。\n如果我们想让情况变成匹配边会多一条，那就思考一下“取反”操作，即将匹配边变为非匹配边，反之同理。\n可得：\n可以得到这样的匹配 $M\u0026rsquo;=((x_3,y_4),(x_4,y_3),(x_2,y_1),(x_1,y_2))$。\n仔细思考，发现匹配仍然合法。交错轨也还存在。\n可以证明，当不能再找到增广路时，就已经得到了一个最大匹配。\n为什么？\n假设还能再找到一条增广路，那经过取反操作必定可以多增加一条匹配边。那最大匹配是最终形态，必定不会再有一条增广路。\n而这，就是匈牙利算法的思路。\n增广路径性质\r$P$ 的路径长度必定为奇数，第一条边和最后一条边都不属于 $M$，因为两个端点分属两个集合，且未匹配。 $P$ 经过取反操作可以得到一个更大的匹配 $M\u0026rsquo;$。 $M$ 为 $G$ 的最大匹配当且仅当不存在相对于 $M$ 的增广路径。 以上很好理解，根据定义可推出。\n匈牙利算法\r为什么要用匈牙利算法\r匈牙利算法就是用增广路求最大匹配问题，由匈牙利数学家 Edmonds 于1965年提出。\n匈牙利算法长什么样\r置 $M$ 为空 找出一条增广路径 $P$，通过取反操作获得更大的匹配$M\u0026rsquo;$代替$M$ 重复步骤2，直至再也找不出新增广路 怎么找增广路\r第一个想法肯定是用 dfs：\n从 $X$ 部一个未匹配的顶点 $u$ 开始，找一个未访问的邻接点 $v$（$v$ 一定是 $Y$ 部顶点）。\n对于 $v$，分两种情况：\n如果 $v$ 未匹配，则已找到一条增广路。 如果 $v$ 已匹配，设 $v$ 的匹配顶点为 $w$（$w$ 一定属 $X$ 部）。此时边 $(w,v)$ 为匹配边，根据“取反”思想，要将 $(w,v)$ 改为未匹配，$(u,v)$ 改为匹配。怎样才能实现这一点？要看从 $w$ 为起点出发能不能找到一条新增广路 $P\u0026rsquo;$。如果成功，那 $u\\rightarrow v\\rightarrow P\u0026rsquo;$ 就是以 $u$ 为起点的增广路径。 那么我们就成功地把匈牙利算法核心部分搞懂了，可以上代码了。\n代码实现匈牙利算法\r寻找增广路部分\rcode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // cx[i]表示与X部i点匹配的Y部顶点编号，cy[i]表示与Y部i点匹配的X部顶点编号 bool dfs(ll x) { for (auto y : v[x]) { if (!vis[y]) { vis[y] = 1; if (cy[y] == -1 || dfs(cy[y])) { cx[x] = y, cy[y] = x; return 1; } } } return 0; } 匈牙利算法主函数\rcode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define mem(a,b) memset(a,b,sizeof(a)) ll maxmatch() { ll ans = 0; mem(cx, -1); mem(cy, -1); rp(i, 1, n) { if (cx[i] == -1) { mem(vis, 0); ans += dfs(i); } } return ans; } 板题\u0026amp;后记\r前几天原题检测，考了一些最大匹配的原题。复习时才发现有很多纰漏平时没注意到，所以写了这篇文章。\n还是挺耗费精力的，因为这种知识和图片打交道比较多，制作图片和上传都挺麻烦的。\n挂个板子吧。\n[USACO4.2]完美的牛栏The Perfect Stall\n这里挂两个代码，在连接$X$部与$Y$部方面有些不同，根据个人习惯取舍咯……\n本人主要是按照题目意思及时变通，并没有什么常用的版本。\n版本 1：用一个数组存下两种关系（个人较常用）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define mem(a, b) memset(a, b, sizeof(a)) const ll MAXN = 1e4 + 5; // 这里要注意一下，不然会RE ll n, m; ll s[MAXN]; bool vis[MAXN]; ll c[MAXN]; ll sum, en[MAXN \u0026lt;\u0026lt; 1], hed[MAXN], lst[MAXN \u0026lt;\u0026lt; 1]; void add(ll x, ll y) { en[++sum] = y; lst[sum] = hed[x]; hed[x] = sum; } bool dfs(ll x) { for (ll i = hed[x]; i; i = lst[i]) { ll y = en[i]; if (!vis[y]) { vis[y] = 1; if (!c[y] || dfs(c[y])) { c[y] = x; return 1; } } } return 0; } ll maxmatch() { ll ans = 0; rp(i, 1, n) { mem(vis, 0); if (dfs(i)) ++ans; } return ans; } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); rp(i, 1, n) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;s[i]); rp(j, 1, s[i]) { ll t; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;t); add(i, t); } } printf(\u0026#34;%lld\\n\u0026#34;, maxmatch()); return 0; } 版本 2：不同部用不同数组（根据题目不同偶尔采用）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rp(i, o, p) for (ll i = o; i \u0026lt;= p; ++i) #define pr(i, o, p) for (ll i = o; i \u0026gt;= p; --i) #define pb push_back #define mem(a, b) memset(a, b, sizeof(a)) const ll MAXN = 200 + 5; ll n, m; vector\u0026lt;ll\u0026gt; v[MAXN \u0026lt;\u0026lt; 1]; ll cx[MAXN], cy[MAXN \u0026lt;\u0026lt; 1]; bool vis[MAXN \u0026lt;\u0026lt; 1]; bool dfs(ll x) { for (auto y : v[x]) { if (!vis[y]) { vis[y] = 1; if (cy[y] == -1 || dfs(cy[y])) { cx[x] = y, cy[y] = x; return 1; } } } return 0; } ll maxmatch() { ll ans = 0; mem(cx, -1); mem(cy, -1); rp(i, 1, n) { if (cx[i] == -1) { mem(vis, 0); ans += dfs(i); } } return ans; } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m); rp(i, 1, n) { ll x; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); rp(j, 1, x) { ll y; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;y); v[i].pb(y + n), v[y + n].pb(i); } } printf(\u0026#34;%lld\\n\u0026#34;, maxmatch()); return 0; } ","date":"2023-05-21T00:05:00+08:00","image":"https://werchange.github.io/img/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/p2.png","permalink":"https://werchange.github.io/p/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/","title":"二分图最大匹配匈牙利算法"},{"content":"质数\r质数，又称素数。如果一个数 $a \\in \\N^+（a\\neq 1）$ 的因子有且仅有$1$和它本身，则称数 $a$ 为质数。\n普通筛法\r过程\r枚举 $[2,n-1]$，如果 $n$ 在这个范围内有因子，则 $n$ 不是因数。 因为 $n$ 的因子成对出现，所以我们可以枚举 $[2,\\sqrt{n}]$。 Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool isprime(int n) { for(int i=2;i*i\u0026lt;=n;i++) if(n%i==0) return 0; return 1; } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=2;i\u0026lt;=n;i++) //将i=1排除掉。 if(isprime(i)) printf(\u0026#34;%d\\n\u0026#34;,i); return 0; } 时间复杂度\r时间复杂度为 $\\Omicron(N\\sqrt{N})$，因为太慢了，所以有以下两种更快的筛法。\n埃式筛法\r过程\r循环从 $2$ ~ $n$，判断当前的下标 $i$ 是否曾经被确认为合数。 如果 $i$ 不是合数，那么将质数 $i$ 放进质数集合里并不断成倍增加，再将增加所得的数标记为合数，直至大于 $n$ 为止。如果 $i$ 为合数，重复找下一个 $i$。 Code\r1 2 3 4 5 6 7 8 9 10 11 void getprime(int n) { for(int i=2;i\u0026lt;=n;i++) { if(flgs[i]==1) // flgs[i]表示i是否为合数 continue; primes[++cnt]=i; // primes[]表示质数集合 for(int j=i;j\u0026lt;=n/i;j++) flgs[j*i]=1; } } 时间复杂度\r时间复杂度为 $\\Omicron(N \\log N)$。\n欧拉筛法\r过程\r循环从 $2$ ~ $n$，判断当前的下标 $i$ 是否曾经被确认为合数。 如果 $i$ 不是合数，把质数 $i$ 放进质数的集合里。 无论 $i$ 是不是合数，都遍历一遍质数集合，并将集合中遍历到的当前元素 $p_j$ 乘以 $i$ 后标记为合数，直至 $p_j\\times i \u0026gt;n$。 执行步骤 3 时，如果 $p_j\\mid i$，先将 $p_j\\times i$ 标记为合数，再重新找下一个 $i$。 Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void getprime(int n) { for(int i=2;i\u0026lt;=n;i++) { if(flgs[i]==0) primes[++cnt]=i; for(int j=1;j\u0026lt;=cnt;j++) { if(primes[j]*i\u0026gt;n) break; flgs[primes[j]*i]=1; if(i%primes[j]==0) break; } } } 时间复杂度\r时间复杂度为 $\\Omicron(N)$。\n","date":"2023-04-25T20:49:00+08:00","permalink":"https://werchange.github.io/p/%E8%B4%A8%E6%95%B0%E5%8F%8A%E5%85%B6%E7%AD%9B%E6%B3%95/","title":"质数及其筛法"},{"content":"平衡树\r是一种二叉查找树，其平衡性使得树的深度在$\\log n$以内，增加、删除等操作可以做到 $O(\\log n)$.\n平衡树的实现有多种，本文主要介绍 AVL，Treap，FHQ Treap 与 Splay .\nAVL\r介绍\rAVL 是这些算法中时间复杂度最优秀的，也是码量最大的.\n其原因在于：AVL 是维护绝对平衡，即左子树高度与右子树高度之差 $\\leq 1$\n所以每一次维护造就了优秀的时间复杂度 与超大的码量 .\n平衡维护\r可以说，平衡维护是铸造二叉平衡树最关键的一步，也是最难理解的一步.\n如何维护？\n1.先判断左子树与右子树高度之差.\r2.再判断较高的那一棵子树是它的左子树高还是右子树高.\r3.最后再进行旋转操作使其平衡.\r相信第1步很容易理解，这里不作过多解释.\n为什么会有第2步的判断？\n因为可能出现不同的情况，我们也需要做出不同的旋转.\n如下图，左子树根节点（节点3）的左儿子（节点2）使左子树高度增加为2，而右子树高度为0，所以平衡树不平衡. 再如下图，左子树根节点（节点15）的右儿子（节点18）使左子树高度增加为2，而右子树高度为0，所以平衡树不平衡. 同理，也有右子树高度高于左子树的情况. 明显可见，当多出来的那个节点与它的父亲、父亲的父亲（祖父）成一条线时，只需要通过一次旋转. 当不成一条线时，需要通过两次旋转.\n单旋转分为两种，左旋（zag）与右旋（zig）.\n如下图，为左旋. 如下图，为右旋. 双旋转则多为先进行一次方向旋转，使其呈链状后，再进行一次反方向旋转.\n如下图，为需要维护的不平衡状态. 又如下图，为进行旋转（左旋A，B）使三点共链的状态. 再如下图，为进行反方向旋转（右旋C，B）使其平衡的状态. 最后保持平衡.\n因为其不同方向两次旋转的特性，所以双旋转分为左右旋（zagzig）和右左旋（zigzag）.\n代码实现平衡维护\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void mountain(ll \u0026amp;r) // 注意引用\u0026amp; { ll lf=ls(r),rg=rs(r); // ls(r)为表示r的左儿子的函数，rs(r)反之 if(tr[lf].hi==tr[rg].hi+2) { if(tr[ls(lf)].hi==tr[rg].hi+1) rote(r,1); // 单旋转，1表示zig，0反之 else if(tr[rs(lf)].hi==tr[rg].hi+1) rote2(r,0); // 双旋转，0表示zagzig，1反之 } else if(tr[rg].hi==tr[lf].hi+2) { if(tr[rs(rg)].hi==tr[lf].hi+1) rote(r,0); else if(tr[ls(rg)].hi==tr[lf].hi+1) rote2(r,1); } pushup(r); } 代码实现旋转操作\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void rote(ll \u0026amp;r,ll op) { ll t=tr[r].ch[!op]; tr[r].ch[!op]=tr[t].ch[op]; tr[t].ch[op]=r; pushup(r),pushup(t); r=t; } void rote2(ll \u0026amp;r,ll op) { rote(tr[r].ch[op],op); rote(r,!op); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+5,INF=0x3f3f3f3f; struct AVL { ll ch[2],sz,val,hi,cnt; }tr[MAXN]; ll rt,pcnt; void pushup(ll r) { if(!r) return; tr[r].hi=max(tr[ls(r)].hi,tr[rs(r)].hi)+1; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void rote(ll \u0026amp;r,ll op) { ll t=tr[r].ch[!op]; tr[r].ch[!op]=tr[t].ch[op]; tr[t].ch[op]=r; pushup(r),pushup(t); r=t; } void rote2(ll \u0026amp;r,ll op) { rote(tr[r].ch[op],op); rote(r,!op); } void mountain(ll \u0026amp;r) { ll lf=ls(r),rg=rs(r); if(tr[lf].hi==tr[rg].hi+2) { if(tr[ls(lf)].hi==tr[rg].hi+1) rote(r,1); else if(tr[rs(lf)].hi==tr[rg].hi+1) rote2(r,0); } else if(tr[rg].hi==tr[lf].hi+2) { if(tr[rs(rg)].hi==tr[lf].hi+1) rote(r,0); else if(tr[ls(rg)].hi==tr[lf].hi+1) rote2(r,1); } pushup(r); } void ins(ll \u0026amp;r,ll x) { if(!r) { tr[++pcnt].val=x,r=pcnt; pushup(r); return; } if(x\u0026lt;tr[r].val) ins(ls(r),x); else ins(rs(r),x); mountain(r); } ll del(ll \u0026amp;r,ll x) { ll tmp; if(tr[r].val==x||x\u0026lt;tr[r].val\u0026amp;\u0026amp;!ls(r)||x\u0026gt;tr[r].val\u0026amp;\u0026amp;!rs(r)) { tmp=tr[r].val; if(!ls(r)||!rs(r)) { r=ls(r)+rs(r); return tmp; } tr[r].val=del(ls(r),x); } else { if(x\u0026lt;tr[r].val) tmp=del(ls(r),x); else tmp=del(rs(r),x); } mountain(r); return tmp; } ll grank(ll r,ll x) { if(!r) return 1; if(x\u0026lt;=tr[r].val) return grank(ls(r),x); return tr[ls(r)].sz+1+grank(rs(r),x); } ll xth(ll r,ll x) { if(tr[ls(r)].sz\u0026gt;=x) return xth(ls(r),x); if(tr[ls(r)].sz+1\u0026gt;=x) return tr[r].val; return xth(rs(r),x-tr[ls(r)].sz-1); } ll pre(ll r,ll x) { if(!r) return -INF; if(tr[r].val\u0026gt;=x) return pre(ls(r),x); return max(tr[r].val,pre(rs(r),x)); } ll nxt(ll r,ll x) { if(!r) return INF; if(tr[r].val\u0026lt;=x) return nxt(rs(r),x); return min(tr[r].val,nxt(ls(r),x)); } int main() { ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(rt,x); if(op==2) del(rt,x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(rt,x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(rt,x)); if(op==5) printf(\u0026#34;%lld\\n\u0026#34;,pre(rt,x)); if(op==6) printf(\u0026#34;%lld\\n\u0026#34;,nxt(rt,x)); } } Treap\r介绍\r虽然 AVL 敲可爱哒~ 但是在考场上真的来得及打吗？\n其实只要你练得够多，最快可在10min内打完，一般人也可以练进12min.\n明显地，维护平衡操作太长了，可不可以省去？\n或许我们用一些随机值赋值给不同节点，使其成为节点的优先级，在构造二叉查找树时使其满足点权有序性与优先级（随机值）有序性.\n如果这样，随机生成的数字一般可以使二叉查找树接近平衡.可理解为相对平衡但不是绝对平衡.\n当然，除非你考前被奆佬%而rp\u0026ndash;， 一般随机值不会刚好使其变成一条链. 在大数据下更具有代表性，即维护平衡树平衡的成功概率与数据大小成正比.\n所以，就有了时间复杂度不如 AVL 优秀，但是足够的—— Treap ！！\n$Treap$=$Tree+Heap$.\n从名字上可见它满足点权有序性（二叉查找 tree ），和优先级（随机值）有序性（大根或小根 heap ）.\n平衡维护\r其实 Treap 的维护与 AVL 很像，这里就不放图了.\n它们之间的区别或许只是维护时的条件不同.\nAVL 是当左右子树高度相差超过1时进行维护 Treap 是当左右子树优先级小于（或大于，这里不作定性要求，但是同一代码中必须都是小于或大于）根节点优先级时进行维护 还有一点，因为 Treap 讲究好写，所以只需要在插入数据的时候维护一下就可以了，删除后不用再次维护.\n代码实现插入数据与维护\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void pushup(ll r) { if (!r) return; tr[r].sz = tr[ls(r)].sz + tr[rs(r)].sz + 1; } void ins(ll \u0026amp;r, ll x) { if (!r) { tr[++pcnt].val = x; tr[pcnt].pri = rand(); r = pcnt; pushup(r); return; } if (x \u0026lt; tr[r].val) { ins(ls(r), x); if (tr[ls(r)].pri \u0026gt; tr[r].pri) rote(r, 1); // 旋转操作见AVL } else { ins(rs(r), x); if (tr[rs(r)].pri \u0026gt; tr[r].pri) rote(r, 0); } pushup(r); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN = 5e5 + 5, INF = 0x3f3f3f3f; struct Treap { ll ch[2], sz, val, pri; } tr[MAXN]; ll rt, pcnt; ll fa[MAXN]; void pushup(ll r) { if (!r) return; tr[r].sz = tr[ls(r)].sz + tr[rs(r)].sz + 1; } void rote(ll \u0026amp;r, ll op) { ll t = tr[r].ch[!op]; tr[r].ch[!op] = tr[t].ch[op]; tr[t].ch[op] = r; pushup(r), pushup(t); r = t; } void ins(ll \u0026amp;r, ll x) { if (!r) { tr[++pcnt].val = x; tr[pcnt].pri = rand(); r = pcnt; pushup(r); return; } if (x \u0026lt; tr[r].val) { ins(ls(r), x); if (tr[ls(r)].pri \u0026gt; tr[r].pri) rote(r, 1); } else { ins(rs(r), x); if (tr[rs(r)].pri \u0026gt; tr[r].pri) rote(r, 0); } pushup(r); } ll del(ll \u0026amp;r, ll x) { ll tmp; // 解释一下，因为平衡树是一种二叉查找树， // 所以可以把叶子结点与“要删除节点”换一下位置， // 这样的话二叉查找树的性质不会被改变， // 也成功地删除了节点（其他版本的平衡树删除维护同理） if (x == tr[r].val || x \u0026lt; tr[r].val \u0026amp;\u0026amp; !ls(r) || x \u0026gt; tr[r].val \u0026amp;\u0026amp; !rs(r)) { tmp = tr[r].val; if (!ls(r) || !rs(r)) { r = ls(r) + rs(r); return tmp; } tr[r].val = del(ls(r), x); } else { if (x \u0026lt; tr[r].val) tmp = del(ls(r), x); else tmp = del(rs(r), x); } pushup(r); return tmp; } ll grank(ll r, ll x) { if (!r) return 1; if (x \u0026lt;= tr[r].val) return grank(ls(r), x); return tr[ls(r)].sz + 1 + grank(rs(r), x); } ll xth(ll r, ll x) { if (tr[ls(r)].sz \u0026gt;= x) return xth(ls(r), x); if (tr[ls(r)].sz + 1 \u0026gt;= x) return tr[r].val; return xth(rs(r), x - 1 - tr[ls(r)].sz); } ll pre(ll r, ll x) { if (!r) return -INF; if (tr[r].val \u0026gt;= x) return pre(ls(r), x); return max(tr[r].val, pre(rs(r), x)); } ll nxt(ll r, ll x) { if (!r) return INF; if (tr[r].val \u0026lt;= x) return nxt(rs(r), x); return min(tr[r].val, nxt(ls(r), x)); } int main() { srand(time(0)); ll n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); while (n--) { ll op, x; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;op, \u0026amp;x); if (op == 1) ins(rt, x); if (op == 2) del(rt, x); if (op == 3) printf(\u0026#34;%lld\\n\u0026#34;, grank(rt, x)); if (op == 4) printf(\u0026#34;%lld\\n\u0026#34;, xth(rt, x)); if (op == 5) printf(\u0026#34;%lld\\n\u0026#34;, pre(rt, x)); if (op == 6) printf(\u0026#34;%lld\\n\u0026#34;, nxt(rt, x)); } return 0; } FHQ Treap\r介绍\r可以说，旋转操作是占主流算法的大多数.\n但是一旦牵扯到可连续性等方面乃至理解方面，旋转操作是不太可取的.\n于是范浩强奆佬就发明了不用旋转的 Treap 算法—— FHQ Treap ！！\n也称作无旋 Treap.\n不旋转，怎么维护平衡？\n分裂！！\n合并！！\n分裂操作与合并操作\r分裂split\r分裂操作split是最难理解的也是最关键的一步.\n我们在插入数据和删除数据需要找到一个合适的点.\n而找这个点的路径，可以把树分裂成两部分，把小于等于插入值的分裂到左树，大于的就分裂到右树.\n就这样，我们可以得到两棵树（也有可能是空树）.\n合并merge\r合并操作的对象是两棵树，这两棵树一定满足，左边的树权最大值小于右边的树的权值最小值.\n我们根据其优先级来合并.\n为了描述方面，我们设左边的树为 $L$，右边的树为 $R$.\n首先比较两棵树的树根，谁优先级小，谁就作为新的树根.\n假设 $L$ 的优先级较小，那么 $L$ 的根做新的树根，则问题转换为 $L$ 的右子树与 $R$ 的合并问题了；否则就是 $R$ 的根作为新树的根，问题转换为 $L$ 和 $R$ 的左子树的合并问题了.\n明显地，可以写成递归.\n这样递归下去，直到某棵树为空，则递归结束。\n代码实现split与merge\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void split(ll r,ll \u0026amp;xrt,ll \u0026amp;yrt,ll v) { // r为需要分裂的树的根 // xrt为分裂后将得到左树的树根 // yrt反之 if(!r) xrt=yrt=0; else if(v\u0026lt;tr[r].val) { yrt=r; split(ls(r),xrt,ls(r),v); } else { xrt=r; split(rs(r),rs(r),yrt,v); // 等于v的节点分到左树里 } pushup(r); } void merge(ll \u0026amp;r,ll xrt,ll yrt) { // r为合并后的新根 // xrt为参与合并的左子树的根 // yrt反之 if(!xrt||!yrt) r=xrt+yrt; else if(tr[xrt].pri\u0026lt;tr[yrt].pri) { r=xrt; merge(rs(r),rs(r),yrt); } else { r=yrt; merge(ls(r),xrt,ls(r)); } pushup(r); } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define rep(c,i,a,b) for(c i=a;i\u0026lt;=b;++i) #define per(c,i,a,b) for(c i=a;i\u0026gt;=b;--i) #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+3,INF=0x3f3f3f3f; struct FHQ_Treap { ll ch[2]; ll sz; ll val; ll pri; }tr[MAXN]; ll pcnt,rt,rt1,rt2; void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+1; } void split(ll r,ll \u0026amp;xrt,ll \u0026amp;yrt,ll v) { if(!r) xrt=yrt=0; else if(v\u0026lt;tr[r].val) { yrt=r; split(ls(r),xrt,ls(r),v); } else { xrt=r; split(rs(r),rs(r),yrt,v); } pushup(r); } void merge(ll \u0026amp;r,ll xrt,ll yrt) { if(!xrt||!yrt) r=xrt+yrt; else if(tr[xrt].pri\u0026lt;tr[yrt].pri) { r=xrt; merge(rs(r),rs(r),yrt); } else { r=yrt; merge(ls(r),xrt,ls(r)); } pushup(r); } void ins(ll \u0026amp;r,ll x) { split(r,rt1,rt2,x); tr[++pcnt].val=x,tr[pcnt].pri=rand(),tr[pcnt].sz=1,r=pcnt; merge(rt1,rt1,pcnt); merge(r,rt1,rt2); } void del(ll \u0026amp;r,ll x) { ll rt3; split(r,rt1,rt2,x); split(rt1,rt1,rt3,x-1); merge(rt1,rt1,rt3); merge(r,rt1,rt2); } ll getrank(ll r,ll x) // 数x的排名 { if(r==0) return 1; if(tr[r].val\u0026lt;x) return tr[ls(r)].sz+1+getrank(rs(r),x); return getrank(ls(r),x); } ll xth(ll r,ll x) // 第x个数 { if(tr[ls(r)].sz\u0026gt;=x) return xth(ls(r),x); if(tr[ls(r)].sz+1\u0026gt;=x) return tr[r].val; return xth(rs(r),x-tr[ls(r)].sz-1); } ll getpre(ll r,ll x) // x的前驱 { if(r==0) return -INF; if(x\u0026lt;=tr[r].val) return getpre(ls(r),x); return max(tr[r].val,getpre(rs(r),x)); } ll getnxt(ll r,ll x) // x的后继 { if(r==0) return INF; if(x\u0026gt;=tr[r].val) return getnxt(rs(r),x); return min(tr[r].val,getnxt(ls(r),x)); } int main() { srand(time(0)); ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(rt,x); if(op==2) del(rt,x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(rt,x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(rt,x)); if(op==5) printf(\u0026#34;%lld\\n\u0026#34;,pre(rt,x)); if(op==6) printf(\u0026#34;%lld\\n\u0026#34;,nxt(rt,x)); } return 0; } Splay\r介绍\rSplay 也称为伸展树，它也满足二叉查找树的性质.\n即一个节点的左子树的所有点权都会小于当前节点，右子树反之.\n它和其他平衡树算法最大不同的是，它不需要主动维护平衡，我们只需要在每个操作结束后进行一次splay(x,goal)的操作，它就可以自己维护了.\n当然splay(x,goal)里面还是有旋转操作的.\nsplay(x,goal)伸展操作\rsplay(x,goal)操作也就是伸展操作.\n通过一系列旋转使得 x 转到 goal 节点，旋转也需要分情况而论.\n以下 goal 节点为 root 根节点举例.\n情况一：节点 x 的父节点 y 是根节点. 这时如果 x 是 y 的左儿子，则进行一次 zig 操作；反之同理. 如图 1 所示.\r情况二：节点x的父节点y还有一个父节点z. 且此时三点成链，则进行一次zigzig操作或zagzag操作（是的，此处旋转不需要维护平衡，只是为了将x旋转到目标节点），如图2所示.\r情况三：节点x的父节点y还有父节点z. 且此时三点呈“之”字形，则进行一次zagzig操作或zigzag操作，如图3所示.\r如图5，是一次splay(2,rt)的操作.\n明显地，经过 splay() 操作后，平衡树明显“平衡”了许多.\n所以我们在一些插入、查询等操作后就做一遍 splay().\n这样做的话，时间复杂度可以下降. 但是同样地，常数也就增加了. 所以 Splay 算法是本文 4 个算法中最慢的.\n代码实现 splay(x,goal)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+tr[r].cnt; } void rote(ll x) { ll y=fa[x],z=fa[y],flg=(x==rs(fa[x])); tr[y].ch[flg]=tr[x].ch[!flg]; if(tr[x].ch[!flg]) fa[tr[x].ch[!flg]]=y; tr[x].ch[!flg]=y; fa[y]=x; fa[x]=z; if(z) tr[z].ch[y==rs(z)]=x; pushup(y),pushup(x); } void splay(ll x,ll goal) // 这里goal==0时，表示将x转到根节点 { // 这里3行包含了旋转的3种情况，请自行理解，这里不作过多解释 for(ll y;(y=fa[x])!=goal;rote(x)) if(fa[y]!=goal) rote( ( ( rs(fa[y])==y) == (rs(y)==x) ) ? y : x); if(goal==0) // 如果目标是根节点，那根节点需要更新为x rt=x; } 小飞版来咯~\r【模板】普通平衡树\nCode\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define ls(r) tr[r].ch[0] #define rs(r) tr[r].ch[1] const ll MAXN=5e5+5,INF=0x3f3f3f3f; struct Splay { ll ch[2],sz,val,cnt; }tr[MAXN]; ll rt,pcnt; ll fa[MAXN]; void pushup(ll r) { if(!r) return; tr[r].sz=tr[ls(r)].sz+tr[rs(r)].sz+tr[r].cnt; } void rote(ll x) { ll y=fa[x],z=fa[y],flg=(x==rs(fa[x])); tr[y].ch[flg]=tr[x].ch[!flg]; if(tr[x].ch[!flg]) fa[tr[x].ch[!flg]]=y; tr[x].ch[!flg]=y; fa[y]=x; fa[x]=z; if(z) tr[z].ch[y==rs(z)]=x; pushup(y),pushup(x); } void splay(ll x) { for(ll y;(y=fa[x]);rote(x)) if(fa[y]) rote(((rs(fa[y])==y)==(rs(y)==x))?y:x); rt=x; } void ins(ll x) { if(!rt) { tr[++pcnt].val=x; tr[pcnt].cnt++; rt=pcnt; pushup(rt); return; } ll cur=rt,f=0; while(1) { if(tr[cur].val==x) { tr[cur].cnt++; pushup(cur); pushup(f); splay(cur); return; } f=cur; cur=tr[cur].ch[tr[cur].val\u0026lt;x]; if(!cur) { tr[++pcnt].val=x; tr[pcnt].cnt++; fa[pcnt]=f; tr[f].ch[tr[f].val\u0026lt;x]=pcnt; pushup(pcnt); pushup(f); splay(pcnt); return; } } } ll grank(ll x) { ll res=0,cur=rt; while(1) { if(tr[cur].val\u0026gt;x) cur=ls(cur); else { res+=tr[ls(cur)].sz; if(tr[cur].val==x) { splay(cur); return res+1; } res+=tr[cur].cnt; cur=rs(cur); } } } ll xth(ll x) { ll cur=rt; while(1) { if(ls(cur)\u0026amp;\u0026amp;tr[ls(cur)].sz\u0026gt;=x) cur=ls(cur); else { x-=tr[ls(cur)].sz+tr[cur].cnt; if(x\u0026lt;=0) { splay(cur); return tr[cur].val; } cur=rs(cur); } } } ll pre() { ll cur=ls(rt); if(!cur) return 0; while(rs(cur)) cur=rs(cur); splay(cur); return cur; } ll nxt() { ll cur=rs(rt); if(!cur) return 0; while(ls(cur)) cur=ls(cur); splay(cur); return cur; } void del(ll x) { grank(x); if(tr[rt].cnt\u0026gt;1) { tr[rt].cnt--; splay(rt); return; } if(!rs(rt)\u0026amp;\u0026amp;!ls(rt)) { rt=0; return; } if(!ls(rt)||!rs(rt)) { rt=ls(rt)+rs(rt); fa[rt]=0; return; } ll cur=rt; ll y=pre(); fa[rs(cur)]=y; rs(y)=rs(cur); pushup(rt); } int main() { ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); while(n--) { ll op,x; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;op,\u0026amp;x); if(op==1) ins(x); if(op==2) del(x); if(op==3) printf(\u0026#34;%lld\\n\u0026#34;,grank(x)); if(op==4) printf(\u0026#34;%lld\\n\u0026#34;,xth(x)); if(op==5) ins(x),printf(\u0026#34;%lld\\n\u0026#34;,tr[pre()].val),del(x); if(op==6) ins(x),printf(\u0026#34;%lld\\n\u0026#34;,tr[nxt()].val),del(x); } return 0; } 最后\r本文写得还是很仓促的，有些漏洞大家原谅一下.(^^)\n本文还有很多不完善的地方，例如 AVL 代码没有指针版、图片模糊等.\n欢迎大家在评论区留下建议或疑问、收藏、转发学习.\n转载请注明出处.\n仅供参考、学习用，不商用.\nThe End\n","date":"2023-01-11T09:21:00+08:00","image":"https://werchange.github.io/img/%E5%B9%B3%E8%A1%A1%E6%A0%91/p12.png","permalink":"https://werchange.github.io/p/%E5%B9%B3%E8%A1%A1%E6%A0%91%E8%AF%A6%E8%A7%A3/","title":"平衡树详解"},{"content":"凸透镜成像原理\r前言\r凸透镜成像原理是个有意思的知识。初二教科书会以实验的方式告诉我们原理。\n快要参加中考了，复习的时候老师说了一条公式：\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ 但它为什么是对的，所以来证明一下。\n几何法\r要点：三角形相似。\n证明\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ $证：$\n$\\because\\triangle ABO\\triangle A\u0026rsquo;B\u0026rsquo;O$ $\\qquad$ (三角形ABO相似于三角形A\u0026rsquo;B\u0026rsquo;O)\n$\\therefore AB:A\u0026rsquo;B\u0026rsquo;=u:v$\n$\\because\\triangle COF∽\\triangle A\u0026rsquo;B\u0026rsquo;F$\n$\\therefore CO:A\u0026rsquo;B\u0026rsquo;=f:(v-f)$\n$\\because 四边形ABOC为矩形$\n$\\therefore AB=CO$\n$\\therefore AB:A\u0026rsquo;B\u0026rsquo;=f:(v-f)$ $\\therefore u:v=f:(v-f)$\n$\\therefore u(v-f)=vf$\n$\\therefore uv-uf=vf$\n$\\because uvf\\neq 0$\n$\\therefore \\frac{uv}{uvf}-\\frac{uf}{uvf}=\\frac{vf}{uvf}$\n$\\therefore \\frac{1}{f}-\\frac{1}{v}=\\frac{1}{u}$\n$即$\n$\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}$\n$证毕$.\n函数法\r要点：一次函数，正比例函数。\n证明\n$$\r\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}\r$$ 步骤\n（一）为便于用函数法解决此问题，将凸透镜的主光轴与平面直角坐标系的横坐标轴（$x$ 轴）关联（即重合），将凸透镜的理想折射面与纵坐标轴（$y$ 轴）关联，将凸透镜的光心与坐标原点关联.则：点 $A$ 的坐标为 $(-u,c)$，点 $F$ 的坐标为 $(f,0)$，点 $A\u0026rsquo;$ 的坐标为 $(v,-d)$，点 $C$ 的坐标为 $(0,c)$.\n（二）将 $AA\u0026rsquo;$，$A\u0026rsquo;C$ 双向延长为直线 $l_1$,$l_2$，视作两条函数图象.由图象可知：直线 $l_1$ 为正比例函数图象，直线 $l_2$ 为一次函数图象.\n（三）设直线 $l_1$ 的解析式为 $y=k_1x$，直线 $l_2$ 的解析式为 $y=k_2x+b$.\n依题意，将 $A(-u,c)$，$C(0,c)$，$F(f,0)$ 代入相应解析式，得\n$$\r\\begin{cases}\rc=-uk_1\\\\\rc=b\\\\\r0=k_2f+b\r\\end{cases}\r$$ 得\n$$\r\\begin{cases}\rk_1=-\\frac{c}{u}x\\\\\rk_2=-\\frac{c}{f}\r\\end{cases}\r$$ $\\therefore 两函数解析式为$\n$$\ry=-\\frac{c}{u}x\\\\\ry=-\\frac{c}{f}x+c\r$$ $\\therefore 两函数交点 A\u0026rsquo;(x,y) 满足方程组$\n$$\r\\begin{cases}\ry=-\\frac{c}{u}x\\\\\ry=-\\frac{c}{f}x+c\r\\end{cases}\r$$ $\\because A\u0026rsquo;(v,-d)$\n$$\\therefore\r\\begin{cases}\r-d=-\\frac{c}{u}v\\\\-d=-\\frac{c}{f}v+c\r\\end{cases}$$ $\\therefore -\\frac{c}{u}v=-\\frac{c}{f}v+c=-d$\n$\\therefore \\frac{c}{u}v=\\frac{c}{f}v+c=d$\n$\\therefore \\frac{cv}{u}=\\frac{cv}{f}+c$\n$\\therefore cvf=cuv-cuf$（两边同乘 $uf$）\n$\\therefore vf=uv-uf$\n$\\because uvf\\neq0$\n$\\therefore \\frac{vf}{uvf}=\\frac{uv}{uvf}-\\frac{uf}{uvf}$\n$\\therefore \\frac{1}{u}=\\frac{1}{f}-\\frac{1}{v}$\n$即$\n$\\frac{1}{u}+\\frac{1}{v}=\\frac{1}{f}$\n$证毕.$\n结尾\r这篇文章之前写过了，2024.6.6 进行了修改，使其更加可读。\n","date":"2022-11-29T19:23:00+08:00","image":"https://werchange.github.io/img/%E5%87%B8%E9%80%8F%E9%95%9C/p1.png","permalink":"https://werchange.github.io/p/%E5%87%B8%E9%80%8F%E9%95%9C%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86/","title":"凸透镜成像原理"},{"content":"update:2023.07.19 更新了堆优化版本的 Dijkstra\nupdate:2023.09.21 更新了时间复杂度讨论并修改了堆优化 Dij\nDijkstra\r什么是Dijkstra\rDijkstra采用了贪心的策略。\n在一张连通图中，我们将点分类为已知点和未知点。\n什么是已知点？就是已经遍历过的，例如原点（出发点）就是一个已知点。\n什么是未知点？顾名思义，就是未遍历到的点（除了已知点，剩下的就是未知点）\n理解贪心策略\r这里举一个简单的栗子：\n夏福要去 supermarket，他面前可以选择 3 个商店：\n1.壹加壹超市，据夏福 1000m 2.美宜佳商店，据夏福 500m 3.711超市，据夏福 200m 他该去哪个超市呢？\n这里很容易看出来，肯定是选择第 3 种方案。\n没错，这就是从夏福（原点）到超市（终点）的最短路径。也就是贪心策略。\n思考实现代码\r因为贪心只能保证局部最优，不能保证全局最优，所以我们还是需要去遍历，但是我们可以缩小遍历的范围。\n假想现在从已知点可以到达三个中转站，最后都可以到终点。\n那么从起点到终点的路径就是：起点到中转站的路径 + 中转站到终点的路径\n我们想让起点到中转站的距离尽可能的小，那肯定是选择据起点最近的中转站作为新的起点（新的已知点）\n我们就可以把那个点当作起点，继续找最短路径就好了。\n原来那个点怎么办？\n丢进垃圾桶里~\n代码实现\r题目： 输出从 $s$ 到 $t$ 的最短路，并换行输出最短路径 Input\n1 2 3 4 5 6 7 8 9 5 7 1 2 10 1 4 30 1 5 100 2 3 50 3 5 10 4 3 20 4 5 60 1 5 Output\n1 2 60 1 4 3 5 Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; int edge[505][505]; int ss, tt; bool vis[505]; pair\u0026lt;int, int\u0026gt; dis[505]; // 相当于一个变量里有两个成员：一个是距离，另一个是数组下标所连接的点 vector\u0026lt;int\u0026gt; q[505]; vector\u0026lt;int\u0026gt; ans; bool cmp(int a, int b) { return a \u0026lt; b; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); // 输入点的个数n，边的数量m for (int i = 1; i \u0026lt;= m; i++) { int l, r, v; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;v); // 输入边的信息：边连接的两个点l、r，和边的权值v edge[l][r] = v; // 表示从l到r这个点的权值是v /* 因为这个代码是有向图的最短路问题，如果是无向图的话应该再加上下面这行代码： edge[r][l] = v; 这个表示r到l的路径边权是v */ } scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;ss, \u0026amp;tt); // 输入ss（原点）和tt（终点），这个代码是输出从ss到tt的最短路径 for (int i = 1; i \u0026lt;= n; i++) dis[i].first = 1e9; // 初始化从原点到第i个点的路径全部为正无穷（这里只要数据够大就行了） fill(vis, vis + n + 1, 0); // 初始化所有的点都没被访问过 dis[ss].first = 0; // 从原点到原点的距离肯定是0 dis[ss].second = ss; // 默认原点和原点相连 for (int i = 1; i \u0026lt;= n; i++) { int tmp = -1; // 存储下标的临时变量 for (int j = 1; j \u0026lt;= n; j++) { if (!vis[j] \u0026amp;\u0026amp; (tmp == -1 || dis[j] \u0026lt; dis[tmp])) { // 只要 (j未被访问过) 并且只要达到 [(tmp未赋值) 或 (找到离i点有更近的点)] 的条件之一 tmp = j; // tmp就赋值为j } } vis[tmp] = 1; // 完事之后，备注tmp已经被访问过了，丢进**垃～圾～桶～**里 for (int j = 1; j \u0026lt;= n; j++) { if (dis[tmp].first + edge[tmp][j] \u0026lt; dis[j].first \u0026amp;\u0026amp; tmp != j \u0026amp;\u0026amp; edge[tmp][j]) { /* 如果 (到tmp的距离 + tmp到j的距离 \u0026lt; 原来到j的距离) 并且 (tmp和j不是同一个点) 并且 (tmp到j的距离不是0) 的话 */ dis[j].first = dis[tmp].first + edge[tmp][j]; dis[j].second = tmp; // 到j的距离重新赋值，与j相邻的点就变为tmp } } } printf(\u0026#34;%d\\n\u0026#34;, dis[tt].first); // 输出终点的距离 int temp = tt; while (dis[temp].second != ss) // 只要与temp这个临时变量相邻的不是起点，就进行 { ans.push_back(temp); // 把temp存储进ans数组里 temp = dis[temp].second; // temp就重新赋值 } ans.push_back(temp); // 最后一个点会跳出循环，所以要存储 ans.push_back(ss); // 把原点也放进去 for (int i = ans.size() - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d \u0026#34;, ans[i]); // 倒过来输出就行了 } } 注意：\rDijkstra 采用的是贪心的策略，所以遇上有负边的图时，它就会陷入自环中。\nSPFA\r什么是 SPFA\r相对 Dijkstra 来讲，在随机生成数据中，会比Dijkstra会更快一点。\n它是基于邻接表的基础写的。\n理解邻接表\r在一张连通图中，一个点并不总是只连着一个点。\n举个粒子：\n小 A 家处于十字路口，可以从小 A 家到小 B 家、小 C 家、小 D 家等多个 good friends 的家。\n而对于小 A 家的邻接表就是： $B\\to C\\to D$\n代码实现\r题目：给一堆数据，输出 $1$ 到 $n$ 的最短路 Input\n1 2 3 4 5 6 7 8 4 7 1 2 68 1 3 19 1 4 66 2 3 23 3 4 65 3 2 57 4 1 68 Output\n1 66 Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; struct edge { int s, e, val; }; int maxx = INT_MIN; int step; vector\u0026lt;edge\u0026gt; b[5005]; queue\u0026lt;int\u0026gt; q; int dis[5005]; bool vis[5005]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { int x, y, v; edge ee; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;v); ee.s = x, ee.e = y, ee.val = v; b[x].push_back(ee); // 存储x的邻接表 } fill(dis, dis + n + 1, 1e9); // 初始化路径全部为正无穷（数据足够大就行） q.push(1); dis[1] = 0; vis[1] = 1; while (!q.empty()) { // STL宽搜 step++; if (step \u0026gt; m) { // 出现负环，直接退出 printf(\u0026#34;No Solution\u0026#34;); return 0; } int u = q.front(); q.pop(); for (int i = 0; i \u0026lt; b[u].size(); i++) { // 对于当前这个u点的邻接点 int vv = b[u][i].val; int en = b[u][i].e; if (dis[u] + vv \u0026lt; dis[en]) { // 如果 (到u点距离) + (从u点到它的邻接点的距离) \u0026lt; (原来的到en的距离) dis[en] = dis[u] + vv; if (!vis[en]) { // 在压入队列之前进行标记，否则会陷入死循环 vis[en] = 1; q.push(en); } } } vis[u] = 0; // 标记这个点《 免 费 》了（free这个点） } printf(\u0026#34;%d\u0026#34;, dis[n]); } Floyd\r什么是 Floyd\r就是运用枚举中间点进行松弛（专业术语，指令这个点距离最小）每个点的距离。\n理解枚举中间点\r还是举个梨子：\n小 A 和小 B 有一定的亲密度，为了使他们的亲密度更近，需要一个中介来帮忙。通过中介的帮忙，他们是否能提升之间的亲密度呢？所以我们就枚举一下。\n代码实现\rCode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (i != j \u0026amp;\u0026amp; i != k \u0026amp;\u0026amp; j != k) { if (dis[i][k] + dis[k][j] \u0026lt; dis[i][j]) { dis[i][j] = dis[i][k] + dis[k][j]; // 这样写的话，无论是有向图还是无向图都成立 } } } } } 但是这个时间复杂度是\n$O(n^3)$\n《没 逝 ， 就 慢 了 亿 点 点》\n堆优化Dijkstra\r思想\r因为Dijkstra类似于贪心的策略，每次都选择边权最小的边。如果我们用小根堆来维护呢？\n是的，所以堆优化 Dijkstra 用到了优先队列优化。\n因为曾有“关于 SPFA ——他死了”的一说，所以这个就很吃香。更好的是，这个和 SPFA 代码实现很像，所以直接入手是很容易的。\n代码实现\rcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define pb push_back const int MAXN=500+5,MAXM=500+5,INF=0x3f3f3f3f3f3f3f3f; int n,m; int dis[MAXN]; bool vis[MAXN]; int su,en[MAXM\u0026lt;\u0026lt;1],vl[MAXM\u0026lt;\u0026lt;1],hd[MAXN],lt[MAXM\u0026lt;\u0026lt;1]; struct node { int id,dis; bool operator\u0026gt;(const node \u0026amp;T)const { return dis\u0026gt;T.dis; } }; void add(int u,int v,int w) { en[++su]=v,vl[su]=w,lt[su]=hd[u],hd[u]=su; } int Dij() { priority_queue\u0026lt;node,vector\u0026lt;node\u0026gt;,greater\u0026lt;node\u0026gt;\u0026gt; q; memset(vis,0,sizeof(vis)); memset(dis,0x3f,sizeof(dis)); dis[1]=0,vis[1]=1; q.push({1,0}); while(!q.empty()) { int u=q.top().id;q.pop(); for(int i=hd[u];i;i=lt[i]) { int v=en[i],w=vl[i]; if(dis[v]\u0026gt;dis[u]+w) { dis[v]=dis[u]+w; if(!vis[v]) { vis[v]=1; q.push({v,dis[v]}); } } } vis[u]=0; } if(dis[n]==INF) return -1; return dis[n]; } signed main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=m;i++) { int u,v,w; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v,w),add(v,u,w); } printf(\u0026#34;%lld\\n\u0026#34;,Dij()); return 0; } 时间复杂度讨论\r堆优化 Dij：$O(m\\log m)$\n朴素 Dij：$O(n^2)$ SPFA：$O(nm)$（最坏情况） Floyd：$O(n^3)$\n一般来说，无负边权就选择 Dij，对于是否采用堆优化，取决于图的稀疏程度。\n关于 SPFA…… ","date":"2022-06-02T20:32:00+08:00","image":"https://werchange.github.io/img/%E6%9C%80%E7%9F%AD%E8%B7%AF/spfa.png","permalink":"https://werchange.github.io/p/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","title":"图论——最短路径问题"}]